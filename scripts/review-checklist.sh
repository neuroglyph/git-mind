#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------------
# Git Mind Mechanical Architecture Gates
# -----------------------------------------------------------------------------
# What this checks:
# 1) Forbidden generated artifact paths are not tracked/changed.
# 2) JSON Schema files exist for changed contract-ish files.
# 3) Disallow "silent" schema-ish output additions lacking schemaVersion.
# 4) Basic guard against hidden worktree coupling patterns.
#
# Exit codes:
#   0 = pass
#   1 = fail
# -----------------------------------------------------------------------------

ROOT="$(git rev-parse --show-toplevel)"
cd "$ROOT"

RED=$'\033[31m'
YEL=$'\033[33m'
GRN=$'\033[32m'
BLU=$'\033[34m'
RST=$'\033[0m'

fail_count=0
warn_count=0

say()  { echo "${BLU}[check]${RST} $*"; }
pass() { echo "${GRN}[pass ]${RST} $*"; }
warn() { echo "${YEL}[warn ]${RST} $*"; warn_count=$((warn_count+1)); }
fail() { echo "${RED}[fail ]${RST} $*"; fail_count=$((fail_count+1)); }

# -----------------------------------------------------------------------------
# Config (override via env in CI or local shell)
# -----------------------------------------------------------------------------

# Paths that MUST NEVER be tracked as normal source artifacts.
# Single ERE; use '|' for alternation within one pattern, or colon-separate multiple patterns
# (the matches_any_regex_rule helper splits on ':' so either form works).
# Example: "^dist/|^tmp/" or "^dist/:^tmp/"
FORBIDDEN_TRACKED_PATHS_REGEX="${FORBIDDEN_TRACKED_PATHS_REGEX:-^\\.gitmind/materialized/|^\\.gitmind/cache/|^dist/materialized/|^tmp/materialized/}"

# Optional allowlist for publishable generated artifacts.
# If non-empty, generated files outside allowlist fail.
# Single ERE or colon-separated ERE list (see FORBIDDEN_TRACKED_PATHS_REGEX notes above).
PUBLISH_ALLOWLIST_REGEX="${PUBLISH_ALLOWLIST_REGEX:-^docs/published/}"

# Marker used in generated files; if detected in tracked files outside allowlist => fail
# Single ERE or colon-separated ERE list.
GENERATED_MARKER_REGEX="${GENERATED_MARKER_REGEX:-^x-gitmind-generated:|^# Generated by Git Mind|^<!-- Generated by Git Mind -->}"

# Contract directories
SCHEMA_DIR="${SCHEMA_DIR:-contracts/schemas}"
# Matches true contract surface files: dedicated contracts/ trees and public API/formatter modules.
# Intentionally excludes src/cli/ broadly to avoid false positives on every command file change.
CONTRACT_DIR_REGEX="${CONTRACT_DIR_REGEX:-^src/(contracts|api)/|^contracts/|^docs/contracts/}"

# Basic patterns to detect hidden worktree coupling in core paths
WORKTREE_COUPLING_PATTERN="${WORKTREE_COUPLING_PATTERN:-process\\.cwd\\(|fs\\.readFileSync\\(|fs\\.readFile\\(|git\\s+rev-parse\\s+--show-toplevel|git\\s+status}"
CORE_PATH_REGEX="${CORE_PATH_REGEX:-^src/(domain|core|engine|materialization)/}"

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

in_allowlist() {
  local file="$1"
  IFS=':' read -r -a rules <<< "$PUBLISH_ALLOWLIST_REGEX"
  for re in "${rules[@]}"; do
    [[ -z "$re" ]] && continue
    if [[ "$file" =~ $re ]]; then
      return 0
    fi
  done
  return 1
}

matches_any_regex_rule() {
  local file="$1"
  local rules_str="$2"
  IFS=':' read -r -a arr <<< "$rules_str"
  for re in "${arr[@]}"; do
    [[ -z "$re" ]] && continue
    if [[ "$file" =~ $re ]]; then
      return 0
    fi
  done
  return 1
}

# Memoized changed_files: computed once and cached in _CHANGED_FILES_CACHE.
_CHANGED_FILES_CACHE=""
_CHANGED_FILES_COMPUTED=0

changed_files() {
  if [[ $_CHANGED_FILES_COMPUTED -eq 1 ]]; then
    echo "$_CHANGED_FILES_CACHE"
    return
  fi
  local result
  # Prefer staged files when running as a pre-commit hook (no CI SHAs set).
  if [[ -n "${BASE_REF_SHA:-}" && -n "${HEAD_REF_SHA:-}" ]]; then
    result="$(git diff --name-only "$BASE_REF_SHA" "$HEAD_REF_SHA")"
  elif [[ -n "$(git diff --cached --name-only 2>/dev/null)" ]]; then
    # Pre-commit: only check staged files for speed
    result="$(git diff --cached --name-only)"
  else
    # Local fallback against merge-base with main if exists
    if git show-ref --verify --quiet refs/heads/main; then
      local mb
      mb="$(git merge-base HEAD main)"
      result="$(git diff --name-only "$mb" HEAD)"
    else
      result="$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)"
    fi
  fi
  _CHANGED_FILES_CACHE="$result"
  _CHANGED_FILES_COMPUTED=1
  echo "$result"
}

tracked_files() {
  git ls-files
}

# -----------------------------------------------------------------------------
# Check 1: Forbidden tracked paths
# -----------------------------------------------------------------------------
say "Checking forbidden tracked generated paths..."
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if matches_any_regex_rule "$f" "$FORBIDDEN_TRACKED_PATHS_REGEX"; then
    fail "Tracked forbidden artifact path: $f"
  fi
done < <(tracked_files)

if [[ $fail_count -eq 0 ]]; then
  pass "No forbidden tracked generated paths found."
fi

# -----------------------------------------------------------------------------
# Check 2: Changed files in forbidden generated paths
# -----------------------------------------------------------------------------
say "Checking changed files for forbidden generated paths..."
local_forbidden_changes=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if matches_any_regex_rule "$f" "$FORBIDDEN_TRACKED_PATHS_REGEX"; then
    fail "PR/commit changes forbidden artifact path: $f"
    local_forbidden_changes=$((local_forbidden_changes+1))
  fi
done < <(changed_files)

if [[ $local_forbidden_changes -eq 0 ]]; then
  pass "No changed files under forbidden generated paths."
fi

# -----------------------------------------------------------------------------
# Check 3: Generated marker in changed files outside publish allowlist
# (uses changed_files for speed; falls back to tracked_files when empty)
# -----------------------------------------------------------------------------
say "Scanning changed text files for generated marker outside allowlist..."
marker_hits=0
_check3_files="$(changed_files)"
if [[ -z "$_check3_files" ]]; then
  _check3_files="$(tracked_files)"
fi
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  [[ -f "$f" ]] || continue
  # quick skip binary files
  if file "$f" 2>/dev/null | grep -qiE 'binary|image|pdf|archive'; then
    continue
  fi

  if grep -Eq "$GENERATED_MARKER_REGEX" "$f" 2>/dev/null; then
    if ! in_allowlist "$f"; then
      fail "Generated marker found outside publish allowlist: $f"
      marker_hits=$((marker_hits+1))
    fi
  fi
done <<< "$_check3_files"

if [[ $marker_hits -eq 0 ]]; then
  pass "No generated-marker leakage outside publish allowlist."
fi

# -----------------------------------------------------------------------------
# Check 4: Contract-ish changes should include schemas
# -----------------------------------------------------------------------------
say "Checking contract/schema hygiene..."
contract_changed=0
schema_changed=0

while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if [[ "$f" =~ $CONTRACT_DIR_REGEX ]]; then
    contract_changed=$((contract_changed+1))
  fi
  if [[ "$f" == "$SCHEMA_DIR/"* ]] || [[ "$f" =~ \.schema\.json$ ]]; then
    schema_changed=$((schema_changed+1))
  fi
done < <(changed_files)

if [[ $contract_changed -gt 0 && $schema_changed -eq 0 ]]; then
  fail "Contract-related files changed but no schema updates detected in '$SCHEMA_DIR' or '*.schema.json'."
elif [[ $contract_changed -gt 0 && $schema_changed -gt 0 ]]; then
  pass "Contract-related changes include schema updates."
else
  pass "No contract-related changes detected."
fi

# -----------------------------------------------------------------------------
# Check 5: schemaVersion presence for changed JSON-producing files (heuristic)
# -----------------------------------------------------------------------------
say "Checking schemaVersion presence in changed CLI/API/formatter files..."
schema_version_missing=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  # Heuristic target paths
  if [[ "$f" =~ ^src/(cli|api)/ ]] && [[ "$f" =~ \.(js|ts)$ ]]; then
    # If file has JSON-related hints but no schemaVersion token, warn/fail
    if grep -Eq 'json|JSON|--json|outputJson|res\\.json|serialize' "$f" 2>/dev/null; then
      if ! grep -Eq 'schemaVersion' "$f" 2>/dev/null; then
        warn "Potential JSON output file changed without schemaVersion token: $f"
        schema_version_missing=$((schema_version_missing+1))
      fi
    fi
  fi
done < <(changed_files)

if [[ $schema_version_missing -eq 0 ]]; then
  pass "No obvious schemaVersion omissions in changed JSON-ish files."
fi

# -----------------------------------------------------------------------------
# Check 6: Hidden worktree coupling in core paths (heuristic)
# -----------------------------------------------------------------------------
say "Checking for hidden worktree coupling patterns in core paths..."
coupling_hits=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if [[ "$f" =~ $CORE_PATH_REGEX ]] && [[ "$f" =~ \.(js|ts|mjs|cjs)$ ]]; then
    if grep -En "$WORKTREE_COUPLING_PATTERN" "$f" >/dev/null 2>&1; then
      warn "Potential worktree coupling pattern in core path: $f"
      coupling_hits=$((coupling_hits+1))
    fi
  fi
done < <(changed_files)

if [[ $coupling_hits -eq 0 ]]; then
  pass "No obvious worktree coupling patterns in core paths."
fi

# -----------------------------------------------------------------------------
# Check 7: Implicit context — process.cwd() or hardcoded 'HEAD' in domain src/
# Architecture Law: context must be explicit and passed from the CLI boundary.
# Excludes: src/cli/ (legitimate CLI entry point), bin/ (entry point), test/
# -----------------------------------------------------------------------------
say "Checking for implicit context (process.cwd() / hardcoded HEAD) in domain src/..."
implicit_ctx_hits=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  # Only scan changed JS/MJS/CJS files in src/ but NOT src/cli/
  if [[ "$f" =~ ^src/ ]] && [[ ! "$f" =~ ^src/cli/ ]] && [[ "$f" =~ \.(js|mjs|cjs)$ ]]; then
    # Detect process.cwd() — domain functions should receive cwd, not discover it
    if grep -Eq "process\.cwd\(\)" "$f" 2>/dev/null; then
      warn "Implicit context: process.cwd() in domain file $f (pass cwd explicitly)"
      implicit_ctx_hits=$((implicit_ctx_hits+1))
    fi
    # Detect hardcoded 'HEAD' string literals used in graph read calls
    # Allow legitimate uses: epoch node IDs (epoch:HEAD is not valid anyway),
    # default values in context-envelope.js, and string comparisons.
    # Flag patterns like loadGraph/materialize with 'HEAD' nearby.
    if grep -Eq "asOf.*['\"]HEAD['\"]|['\"]HEAD['\"].*asOf" "$f" 2>/dev/null; then
      # Only flag non-context-envelope files (context-envelope.js defines the default legitimately)
      if [[ "$f" != "src/context-envelope.js" ]]; then
        warn "Implicit context: hardcoded HEAD ref outside context-envelope.js in $f"
        implicit_ctx_hits=$((implicit_ctx_hits+1))
      fi
    fi
  fi
done < <(changed_files)

if [[ $implicit_ctx_hits -eq 0 ]]; then
  pass "No implicit context patterns in domain src/ files."
fi

# -----------------------------------------------------------------------------
# Final verdict
# -----------------------------------------------------------------------------
echo
if [[ $fail_count -gt 0 ]]; then
  echo "${RED}❌ Mechanical gates failed:${RST} $fail_count fail(s), $warn_count warning(s)"
  exit 1
fi

echo "${GRN}✅ Mechanical gates passed:${RST} 0 fail(s), $warn_count warning(s)"
# warnings do not fail by default
exit 0
