#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------------
# Git Mind Mechanical Architecture Gates
# -----------------------------------------------------------------------------
# What this checks:
# 1) Forbidden generated artifact paths are not tracked/changed.
# 2) JSON Schema files exist for changed contract-ish files.
# 3) Disallow "silent" schema-ish output additions lacking schemaVersion.
# 4) Basic guard against hidden worktree coupling patterns.
#
# Exit codes:
#   0 = pass
#   1 = fail
# -----------------------------------------------------------------------------

ROOT="$(git rev-parse --show-toplevel)"
cd "$ROOT"

RED=$'\033[31m'
YEL=$'\033[33m'
GRN=$'\033[32m'
BLU=$'\033[34m'
RST=$'\033[0m'

fail_count=0
warn_count=0

say()  { echo "${BLU}[check]${RST} $*"; }
pass() { echo "${GRN}[pass ]${RST} $*"; }
warn() { echo "${YEL}[warn ]${RST} $*"; warn_count=$((warn_count+1)); }
fail() { echo "${RED}[fail ]${RST} $*"; fail_count=$((fail_count+1)); }

# -----------------------------------------------------------------------------
# Config (override via env in CI or local shell)
# -----------------------------------------------------------------------------

# Paths that MUST NEVER be tracked as normal source artifacts.
# Colon-separated regex list.
FORBIDDEN_TRACKED_PATHS_REGEX="${FORBIDDEN_TRACKED_PATHS_REGEX:-^\\.gitmind/materialized/|^\\.gitmind/cache/|^dist/materialized/|^tmp/materialized/}"

# Optional allowlist for publishable generated artifacts.
# If non-empty, generated files outside allowlist fail.
# Colon-separated regex list.
PUBLISH_ALLOWLIST_REGEX="${PUBLISH_ALLOWLIST_REGEX:-^docs/published/}"

# Marker used in generated files; if detected in tracked files outside allowlist => fail
GENERATED_MARKER_REGEX="${GENERATED_MARKER_REGEX:-^x-gitmind-generated:|^# Generated by Git Mind|^<!-- Generated by Git Mind -->}"

# Contract directories
SCHEMA_DIR="${SCHEMA_DIR:-contracts/schemas}"
CONTRACT_DIR_REGEX="${CONTRACT_DIR_REGEX:-^src/(cli|api|contracts)/|^contracts/}"

# Basic patterns to detect hidden worktree coupling in core paths
WORKTREE_COUPLING_PATTERN="${WORKTREE_COUPLING_PATTERN:-process\\.cwd\\(|fs\\.readFileSync\\(|fs\\.readFile\\(|git\\s+rev-parse\\s+--show-toplevel|git\\s+status}"
CORE_PATH_REGEX="${CORE_PATH_REGEX:-^src/(domain|core|engine|materialization)/}"

# -----------------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------------

in_allowlist() {
  local file="$1"
  IFS=':' read -r -a rules <<< "$PUBLISH_ALLOWLIST_REGEX"
  for re in "${rules[@]}"; do
    [[ -z "$re" ]] && continue
    if [[ "$file" =~ $re ]]; then
      return 0
    fi
  done
  return 1
}

matches_any_regex_rule() {
  local file="$1"
  local rules="$2"
  IFS=':' read -r -a arr <<< "$rules"
  for re in "${arr[@]}"; do
    [[ -z "$re" ]] && continue
    if [[ "$file" =~ $re ]]; then
      return 0
    fi
  done
  return 1
}

changed_files() {
  # Works in local and CI.
  # If CI provides BASE_REF_SHA/HEAD_REF_SHA use those.
  if [[ -n "${BASE_REF_SHA:-}" && -n "${HEAD_REF_SHA:-}" ]]; then
    git diff --name-only "$BASE_REF_SHA" "$HEAD_REF_SHA"
  else
    # Local fallback against merge-base with main if exists
    if git show-ref --verify --quiet refs/heads/main; then
      local mb
      mb="$(git merge-base HEAD main)"
      git diff --name-only "$mb" HEAD
    else
      git diff --name-only HEAD~1 HEAD || true
    fi
  fi
}

tracked_files() {
  git ls-files
}

# -----------------------------------------------------------------------------
# Check 1: Forbidden tracked paths
# -----------------------------------------------------------------------------
say "Checking forbidden tracked generated paths..."
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if matches_any_regex_rule "$f" "$FORBIDDEN_TRACKED_PATHS_REGEX"; then
    fail "Tracked forbidden artifact path: $f"
  fi
done < <(tracked_files)

if [[ $fail_count -eq 0 ]]; then
  pass "No forbidden tracked generated paths found."
fi

# -----------------------------------------------------------------------------
# Check 2: Changed files in forbidden generated paths
# -----------------------------------------------------------------------------
say "Checking changed files for forbidden generated paths..."
local_forbidden_changes=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if matches_any_regex_rule "$f" "$FORBIDDEN_TRACKED_PATHS_REGEX"; then
    fail "PR/commit changes forbidden artifact path: $f"
    local_forbidden_changes=$((local_forbidden_changes+1))
  fi
done < <(changed_files)

if [[ $local_forbidden_changes -eq 0 ]]; then
  pass "No changed files under forbidden generated paths."
fi

# -----------------------------------------------------------------------------
# Check 3: Generated marker in tracked files outside publish allowlist
# -----------------------------------------------------------------------------
say "Scanning tracked text files for generated marker outside allowlist..."
marker_hits=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  # quick skip binary files
  if file "$f" 2>/dev/null | grep -qiE 'binary|image|pdf|archive'; then
    continue
  fi

  if grep -Eq "$GENERATED_MARKER_REGEX" "$f" 2>/dev/null; then
    if ! in_allowlist "$f"; then
      fail "Generated marker found outside publish allowlist: $f"
      marker_hits=$((marker_hits+1))
    fi
  fi
done < <(tracked_files)

if [[ $marker_hits -eq 0 ]]; then
  pass "No generated-marker leakage outside publish allowlist."
fi

# -----------------------------------------------------------------------------
# Check 4: Contract-ish changes should include schemas
# -----------------------------------------------------------------------------
say "Checking contract/schema hygiene..."
contract_changed=0
schema_changed=0

while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if [[ "$f" =~ $CONTRACT_DIR_REGEX ]]; then
    contract_changed=$((contract_changed+1))
  fi
  if [[ "$f" == "$SCHEMA_DIR/"* ]] || [[ "$f" =~ \.schema\.json$ ]]; then
    schema_changed=$((schema_changed+1))
  fi
done < <(changed_files)

if [[ $contract_changed -gt 0 && $schema_changed -eq 0 ]]; then
  fail "Contract-related files changed but no schema updates detected in '$SCHEMA_DIR' or '*.schema.json'."
elif [[ $contract_changed -gt 0 && $schema_changed -gt 0 ]]; then
  pass "Contract-related changes include schema updates."
else
  pass "No contract-related changes detected."
fi

# -----------------------------------------------------------------------------
# Check 5: schemaVersion presence for changed JSON-producing files (heuristic)
# -----------------------------------------------------------------------------
say "Checking schemaVersion presence in changed CLI/API/formatter files..."
schema_version_missing=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  # Heuristic target paths
  if [[ "$f" =~ ^src/(cli|api)/ ]] && [[ "$f" =~ \.(js|ts)$ ]]; then
    # If file has JSON-related hints but no schemaVersion token, warn/fail
    if grep -Eq 'json|JSON|--json|outputJson|res\\.json|serialize' "$f" 2>/dev/null; then
      if ! grep -Eq 'schemaVersion' "$f" 2>/dev/null; then
        warn "Potential JSON output file changed without schemaVersion token: $f"
        schema_version_missing=$((schema_version_missing+1))
      fi
    fi
  fi
done < <(changed_files)

if [[ $schema_version_missing -eq 0 ]]; then
  pass "No obvious schemaVersion omissions in changed JSON-ish files."
fi

# -----------------------------------------------------------------------------
# Check 6: Hidden worktree coupling in core paths (heuristic)
# -----------------------------------------------------------------------------
say "Checking for hidden worktree coupling patterns in core paths..."
coupling_hits=0
while IFS= read -r f; do
  [[ -z "$f" ]] && continue
  if [[ "$f" =~ $CORE_PATH_REGEX ]] && [[ "$f" =~ \.(js|ts|mjs|cjs)$ ]]; then
    if grep -En "$WORKTREE_COUPLING_PATTERN" "$f" >/dev/null 2>&1; then
      warn "Potential worktree coupling pattern in core path: $f"
      coupling_hits=$((coupling_hits+1))
    fi
  fi
done < <(changed_files)

if [[ $coupling_hits -eq 0 ]]; then
  pass "No obvious worktree coupling patterns in core paths."
fi

# -----------------------------------------------------------------------------
# Final verdict
# -----------------------------------------------------------------------------
echo
if [[ $fail_count -gt 0 ]]; then
  echo "${RED}❌ Mechanical gates failed:${RST} $fail_count fail(s), $warn_count warning(s)"
  exit 1
fi

echo "${GRN}✅ Mechanical gates passed:${RST} 0 fail(s), $warn_count warning(s)"
# warnings do not fail by default
exit 0
