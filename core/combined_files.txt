# /Users/james/git/git-mind/core/.clang-tidy
---
Checks: |
  -*,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  misc-*,
  modernize-*,
  performance-*,
  portability-*,
  readability-*,
  -modernize-use-trailing-return-type,
  -readability-identifier-length,
  -readability-magic-numbers,
  -cert-err33-c,
  -bugprone-reserved-identifier,
  -cert-dcl37-c,
  -cert-dcl51-cpp

WarningsAsErrors: '*'

HeaderFilterRegex: '.*'

AnalyzeTemporaryDtors: false

FormatStyle: none

CheckOptions:
  - key: readability-identifier-naming.FunctionCase
    value: lower_case
  - key: readability-identifier-naming.VariableCase
    value: lower_case
  - key: readability-identifier-naming.StructCase
    value: lower_case
  - key: readability-identifier-naming.EnumCase
    value: lower_case
  - key: readability-identifier-naming.MacroDefinitionCase
    value: UPPER_CASE
  - key: readability-identifier-naming.TypedefCase
    value: lower_case
  - key: readability-identifier-naming.TypedefSuffix
    value: '_t'
  - key: readability-function-cognitive-complexity.Threshold
    value: '15'
  - key: readability-function-size.StatementThreshold
    value: '50'
  - key: readability-function-size.BranchThreshold
    value: '10'
  - key: readability-function-size.ParameterThreshold
    value: '5'
  - key: cppcoreguidelines-narrowing-conversions.PedanticMode
    value: 'true'

# /Users/james/git/git-mind/core/Makefile
# SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0
# © 2025 J. Kirby Ross / Neuroglyph Collective

# Compiler settings
CC ?= gcc
CFLAGS = -Wall -Wextra -Werror -std=gnu11 -O2
CFLAGS += -I./include
LDFLAGS = -lsodium

# Coverage settings
COVERAGE ?= 0
ifeq ($(COVERAGE),1)
	CFLAGS += --coverage -fprofile-arcs -ftest-coverage
	LDFLAGS += --coverage -lgcov
endif

# Directories
SRC_DIR = src
TEST_DIR = tests
BUILD_DIR = build
OBJ_DIR = $(BUILD_DIR)/obj
BIN_DIR = $(BUILD_DIR)/bin

# Source files
ERROR_SRCS = $(SRC_DIR)/error/error.c
TYPES_SRCS = $(SRC_DIR)/types/id.c $(SRC_DIR)/types/string.c $(SRC_DIR)/types/string_core.c $(SRC_DIR)/types/string_utf8.c $(SRC_DIR)/types/path.c
CRYPTO_SRCS = $(SRC_DIR)/crypto/sha256.c $(SRC_DIR)/crypto/random.c $(SRC_DIR)/crypto/backend.c
UTF8_SRCS = $(SRC_DIR)/utf8/validate.c
ALL_SRCS = $(ERROR_SRCS) $(TYPES_SRCS) $(CRYPTO_SRCS) $(UTF8_SRCS)

# Object files
ERROR_OBJS = $(ERROR_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
TYPES_OBJS = $(TYPES_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
CRYPTO_OBJS = $(CRYPTO_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
UTF8_OBJS = $(UTF8_SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
ALL_OBJS = $(ERROR_OBJS) $(TYPES_OBJS) $(CRYPTO_OBJS) $(UTF8_OBJS)

# Test files
TEST_ERROR = $(TEST_DIR)/unit/test_error.c
TEST_ID = $(TEST_DIR)/unit/test_id.c
TEST_STRING = $(TEST_DIR)/unit/test_string.c
TEST_PATH = $(TEST_DIR)/unit/test_path.c
TEST_SHA256 = $(TEST_DIR)/unit/test_sha256.c
TEST_RANDOM = $(TEST_DIR)/unit/test_random.c
TEST_UTF8 = $(TEST_DIR)/unit/test_utf8.c
TEST_CRYPTO_BACKEND = $(TEST_DIR)/unit/test_crypto_backend.c

# Targets
.PHONY: all clean test

all: dirs test

dirs:
	@mkdir -p $(OBJ_DIR)/error
	@mkdir -p $(OBJ_DIR)/types
	@mkdir -p $(OBJ_DIR)/crypto
	@mkdir -p $(OBJ_DIR)/utf8
	@mkdir -p $(BIN_DIR)

# Build object files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

# Build and run tests
test: dirs $(ALL_OBJS)
	$(CC) $(CFLAGS) $(TEST_ERROR) $(ERROR_OBJS) -o $(BIN_DIR)/test_error $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_ID) $(TYPES_OBJS) $(CRYPTO_OBJS) $(UTF8_OBJS) $(ERROR_OBJS) -o $(BIN_DIR)/test_id $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_STRING) $(TYPES_OBJS) $(CRYPTO_OBJS) $(UTF8_OBJS) $(ERROR_OBJS) -o $(BIN_DIR)/test_string $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_PATH) $(TYPES_OBJS) $(CRYPTO_OBJS) $(UTF8_OBJS) $(ERROR_OBJS) -o $(BIN_DIR)/test_path $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_SHA256) $(CRYPTO_OBJS) $(ERROR_OBJS) -o $(BIN_DIR)/test_sha256 $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_RANDOM) $(CRYPTO_OBJS) $(ERROR_OBJS) -o $(BIN_DIR)/test_random $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_UTF8) $(UTF8_OBJS) -o $(BIN_DIR)/test_utf8 $(LDFLAGS)
	$(CC) $(CFLAGS) $(TEST_CRYPTO_BACKEND) $(CRYPTO_OBJS) $(ERROR_OBJS) -o $(BIN_DIR)/test_crypto_backend $(LDFLAGS)
	@echo "Running tests..."
	@$(BIN_DIR)/test_error
	@$(BIN_DIR)/test_id
	@$(BIN_DIR)/test_string
	@$(BIN_DIR)/test_path
	@$(BIN_DIR)/test_sha256
	@$(BIN_DIR)/test_random
	@$(BIN_DIR)/test_utf8
	@$(BIN_DIR)/test_crypto_backend

clean:
	rm -rf $(BUILD_DIR)
	rm -f *.gcda *.gcno *.gcov
	find . -name "*.gcda" -o -name "*.gcno" -o -name "*.gcov" | xargs rm -f

coverage: clean
	@echo "📊 Building with coverage enabled..."
	@$(MAKE) COVERAGE=1 test
	@echo "📊 Generating coverage report..."
	@gcovr -r . --html --html-details -o $(BUILD_DIR)/coverage.html \
		--exclude 'tests/*' \
		--exclude 'build/*' \
		--fail-under-line 80 \
		--fail-under-branch 70
	@echo "✅ Coverage report generated: $(BUILD_DIR)/coverage.html"
	@gcovr -r . --exclude 'tests/*' --exclude 'build/*'

coverage-text: clean
	@$(MAKE) COVERAGE=1 test
	@gcovr -r . --exclude 'tests/*' --exclude 'build/*' --fail-under-line 80 --fail-under-branch 70

.PHONY: check
check:
	@echo "🔍 Running quality checks on core/..."
	@echo "✓ clang-format check"
	@find . -name "*.c" -o -name "*.h" | xargs clang-format --dry-run --Werror || (echo "❌ Format check failed" && exit 1)
	@echo "✓ All checks passed!"

.PHONY: clean coverage coverage-text check

# /Users/james/git/git-mind/core/include/gitmind/crypto/backend.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_CRYPTO_BACKEND_H
#define GITMIND_CRYPTO_BACKEND_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include "gitmind/result.h"

/* SHA-256 constants */
#define GM_SHA256_DIGEST_SIZE 32
#define GM_SHA256_BLOCK_SIZE 64

/* Forward declaration */
typedef struct gm_sha256_ctx gm_sha256_ctx_t;

/**
 * @brief Crypto backend interface for dependency injection
 * 
 * This allows tests to inject deterministic implementations
 * while production code uses real crypto libraries.
 */
typedef struct gm_crypto_backend {
    /* Backend name for identification */
    const char* name;
    
    /* SHA-256 functions */
    int (*sha256_init)(gm_sha256_ctx_t* ctx);
    int (*sha256_update)(gm_sha256_ctx_t* ctx, const void* data, size_t len);
    int (*sha256_final)(gm_sha256_ctx_t* ctx, uint8_t out[GM_SHA256_DIGEST_SIZE]);
    int (*sha256)(const void* data, size_t len, uint8_t out[GM_SHA256_DIGEST_SIZE]);
    
    /* Random number generation */
    int (*random_bytes)(void* buf, size_t size);
    uint32_t (*random_u32)(void);
    uint64_t (*random_u64)(void);
    
    /* Optional: backend-specific context */
    void* context;
} gm_crypto_backend_t;

/* Result type for backend operations */
GM_RESULT_DEF(gm_result_backend, gm_crypto_backend_t*);

/* Global backend management */
gm_result_backend gm_crypto_set_backend(gm_crypto_backend_t* backend);
gm_crypto_backend_t* gm_crypto_get_backend(void);

/* Default backends */
gm_crypto_backend_t* gm_crypto_backend_libsodium(void);
gm_crypto_backend_t* gm_crypto_backend_test(void);

/* Backend initialization */
gm_result_void gm_crypto_init(void);
gm_result_void gm_crypto_cleanup(void);

#endif /* GITMIND_CRYPTO_BACKEND_H */

# /Users/james/git/git-mind/core/include/gitmind/crypto/random.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_CRYPTO_RANDOM_H
#define GITMIND_CRYPTO_RANDOM_H

#include <stdint.h>
#include <stddef.h>
#include "gitmind/result.h"

/* Define result types for random operations */
GM_RESULT_DEF(gm_result_u32, uint32_t);
GM_RESULT_DEF(gm_result_u64, uint64_t);

/**
 * @brief Fill buffer with cryptographically secure random bytes
 * 
 * Uses libsodium's randombytes_buf() which provides CSPRNG data
 * suitable for cryptographic keys, IDs, and nonces.
 * 
 * @param buf Output buffer
 * @param size Number of random bytes to generate
 * @return gm_result_void Success or error
 */
gm_result_void gm_random_bytes(void* buf, size_t size);

/**
 * @brief Generate a random 32-bit unsigned integer
 * 
 * @return gm_result_u32 containing random value or error
 */
gm_result_u32 gm_random_u32(void);

/**
 * @brief Generate a random 64-bit unsigned integer
 * 
 * @return gm_result_u64 containing random value or error
 */
gm_result_u64 gm_random_u64(void);

#endif /* GITMIND_CRYPTO_RANDOM_H */

# /Users/james/git/git-mind/core/include/gitmind/crypto/sha256.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_CRYPTO_SHA256_H
#define GITMIND_CRYPTO_SHA256_H

#include <stdint.h>
#include <stddef.h>
#include "gitmind/result.h"

/* SHA256 digest size */
#define GM_SHA256_DIGEST_SIZE 32
#define GM_SHA256_BLOCK_SIZE 64

/* SHA256 context for streaming operations */
typedef struct gm_sha256_ctx {
    /* Implementation-specific; users should treat as opaque */
    uint8_t opaque[256];  /* Enough for any backend */
} gm_sha256_ctx_t;

/**
 * @brief Compute SHA256 hash of data in one shot
 * 
 * @param data Input data
 * @param len Length of input data
 * @param out Output buffer for 32-byte digest (big-endian/network order)
 * @return gm_result_void Success or error
 */
gm_result_void gm_sha256(const void* data, size_t len, uint8_t out[GM_SHA256_DIGEST_SIZE]);

/**
 * @brief Initialize SHA256 streaming context
 * 
 * @param ctx Context to initialize
 * @return gm_result_void Success or error
 */
gm_result_void gm_sha256_init(gm_sha256_ctx_t* ctx);

/**
 * @brief Update SHA256 context with more data
 * 
 * @param ctx Context to update
 * @param data Input data chunk
 * @param len Length of input data
 * @return gm_result_void Success or error
 */
gm_result_void gm_sha256_update(gm_sha256_ctx_t* ctx, const void* data, size_t len);

/**
 * @brief Finalize SHA256 computation and get digest
 * 
 * @param ctx Context to finalize (becomes invalid after this call)
 * @param out Output buffer for 32-byte digest (big-endian/network order)
 * @return gm_result_void Success or error
 */
gm_result_void gm_sha256_final(gm_sha256_ctx_t* ctx, uint8_t out[GM_SHA256_DIGEST_SIZE]);

#endif /* GITMIND_CRYPTO_SHA256_H */

# /Users/james/git/git-mind/core/include/gitmind/error.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_ERROR_H
#define GITMIND_ERROR_H

#include <stdint.h>
#include <stdarg.h>
#include <stdbool.h>

/* Error message size constants */
#define GM_ERROR_SMALL_SIZE 48   /* Size for small string optimization */
#define GM_ERROR_MSG_SIZE 256    /* Default message buffer size (deprecated) */

/**
 * @brief Error structure with chaining support and SSO
 * 
 * Errors are heap-allocated and own their cause chain.
 * The caller must free errors they receive.
 * 
 * Uses small string optimization (SSO) for messages:
 * - Messages <= 48 bytes stored inline
 * - Longer messages allocated on heap
 */
typedef struct gm_error {
    int32_t code;                /* Error code (extensible) */
    union {
        char small[GM_ERROR_SMALL_SIZE];  /* Inline storage for small messages */
        char* heap;                       /* Heap pointer for large messages */
    } msg;
    uint16_t len;                /* Message length */
    bool heap_alloc;             /* True if message is heap allocated */
    const char* file;            /* Source file (static string) */
    int line;                    /* Line number */
    const char* func;            /* Function name (static string) */
    struct gm_error* cause;      /* Previous error in chain (owned) */
    void* context;               /* Optional context data */
} gm_error_t;

/**
 * @brief Standard error codes
 * 
 * Using plain int32_t instead of enum for extensibility
 */
typedef enum {
    GM_OK = 0,                   /* Not an error */
    
    /* Generic errors (1-99) */
    GM_ERR_UNKNOWN = 1,          /* Unknown error */
    GM_ERR_NOT_IMPLEMENTED = 2,  /* Feature not implemented */
    GM_ERR_INVALID_ARGUMENT = 3, /* Invalid function argument */
    GM_ERR_INVALID_STATE = 4,    /* Invalid state for operation */
    GM_ERR_NOT_FOUND = 5,        /* Resource not found */
    GM_ERR_ALREADY_EXISTS = 6,   /* Resource already exists */
    GM_ERR_PERMISSION_DENIED = 7,/* Permission denied */
    GM_ERR_TIMEOUT = 8,          /* Operation timed out */
    GM_ERR_CANCELLED = 9,        /* Operation cancelled */
    
    /* Memory errors (100-199) */
    GM_ERR_OUT_OF_MEMORY = 100,  /* Memory allocation failed */
    GM_ERR_BUFFER_TOO_SMALL = 101,/* Buffer too small */
    GM_ERR_MEMORY_CORRUPTED = 102,/* Memory corruption detected */
    
    /* I/O errors (200-299) */
    GM_ERR_IO_FAILED = 200,      /* Generic I/O failure */
    GM_ERR_FILE_NOT_FOUND = 201, /* File not found */
    GM_ERR_PATH_TOO_LONG = 202,  /* Path exceeds limits */
    GM_ERR_DISK_FULL = 203,      /* No space left */
    GM_ERR_READ_ONLY = 204,      /* Read-only filesystem */
    
    /* Validation errors (300-399) */
    GM_ERR_INVALID_FORMAT = 300, /* Invalid data format */
    GM_ERR_INVALID_UTF8 = 301,   /* Invalid UTF-8 encoding */
    GM_ERR_INVALID_PATH = 302,   /* Invalid path (traversal, etc) */
    GM_ERR_INVALID_LENGTH = 303, /* Length constraint violated */
    GM_ERR_INVALID_TYPE = 304,   /* Type mismatch */
    
    /* Git-mind specific (1000+) */
    GM_ERR_INVALID_NODE_ID = 1000,
    GM_ERR_INVALID_EDGE_TYPE = 1001,
    GM_ERR_CYCLE_DETECTED = 1002,
    GM_ERR_CORRUPT_STORAGE = 1003,
} gm_error_code_t;

/**
 * @brief Create new error with formatted message
 * 
 * @param code Error code
 * @param fmt Printf-style format string
 * @param ... Format arguments
 * @return Heap-allocated error (caller must free)
 */
gm_error_t* gm_error_new(int32_t code, const char* fmt, ...);

/**
 * @brief Create error with source location
 * 
 * Usually called via GM_ERROR macro
 */
gm_error_t* gm_error_new_at(
    const char* file, 
    int line, 
    const char* func,
    int32_t code, 
    const char* fmt, 
    ...
);

/**
 * @brief Convenience macro that captures source location
 */
#define GM_ERROR(code, ...) \
    gm_error_new_at(__FILE__, __LINE__, __func__, code, __VA_ARGS__)

/**
 * @brief Add context to existing error
 * 
 * Takes ownership of cause
 */
gm_error_t* gm_error_wrap(
    gm_error_t* cause,
    int32_t code,
    const char* fmt,
    ...
);

/**
 * @brief Propagate error with additional context
 */
#define GM_ERROR_PROPAGATE(cause, code, ...) \
    gm_error_wrap(cause, code, __VA_ARGS__)

/**
 * @brief Try with context - add context on error
 */
#define GM_TRY_CTX(expr, code, ...) \
    do { \
        __auto_type _result = (expr); \
        if (GM_IS_ERR(_result)) { \
            gm_error_t* _err = GM_UNWRAP_ERR(_result); \
            return (typeof(_result)){ \
                .ok = false, \
                .u.err = GM_ERROR_PROPAGATE(_err, code, __VA_ARGS__) \
            }; \
        } \
    } while(0)

/**
 * @brief Free error and its cause chain
 */
void gm_error_free(gm_error_t* error);

/**
 * @brief Format error chain as string
 * 
 * @return Heap-allocated string (caller must free)
 */
char* gm_error_format(const gm_error_t* error);

/**
 * @brief Print error chain to stderr
 */
void gm_error_print(const gm_error_t* error);

#endif /* GITMIND_ERROR_H */

# /Users/james/git/git-mind/core/include/gitmind/result.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_RESULT_H
#define GITMIND_RESULT_H

#include <stdbool.h>
#include <stddef.h>

/* Forward declaration */
typedef struct gm_error gm_error_t;

/**
 * @brief Define a named Result type for a specific value type
 * 
 * This macro creates a new struct type that can hold either a value or an error.
 * Using named types avoids the anonymous struct problem where each expansion
 * creates a different type.
 * 
 * Example:
 *   GM_RESULT_DEF(gm_result_int, int);
 *   GM_RESULT_DEF(gm_result_string, char*);
 */
#define GM_RESULT_DEF(name, T) \
    typedef struct { \
        bool ok; \
        union { \
            T val; \
            gm_error_t* err; \
        } u; \
    } name

/* Define standard result types */
GM_RESULT_DEF(gm_result_void, int);      /* int is dummy for void case */
GM_RESULT_DEF(gm_result_ptr, void*);
GM_RESULT_DEF(gm_result_int, int);
GM_RESULT_DEF(gm_result_bool, bool);
GM_RESULT_DEF(gm_result_size, size_t);

/* Legacy name for compatibility during migration */
typedef gm_result_ptr gm_result_t;

/* Success constructors */
static inline gm_result_void gm_ok_void(void) {
    return (gm_result_void){ .ok = true, .u.val = 0 };
}

static inline gm_result_ptr gm_ok_ptr(void* v) {
    return (gm_result_ptr){ .ok = true, .u.val = v };
}

static inline gm_result_int gm_ok_int(int v) {
    return (gm_result_int){ .ok = true, .u.val = v };
}

static inline gm_result_bool gm_ok_bool(bool v) {
    return (gm_result_bool){ .ok = true, .u.val = v };
}

static inline gm_result_size gm_ok_size(size_t v) {
    return (gm_result_size){ .ok = true, .u.val = v };
}

/* Error constructors */
static inline gm_result_void gm_err_void(gm_error_t* e) {
    return (gm_result_void){ .ok = false, .u.err = e };
}

static inline gm_result_ptr gm_err_ptr(gm_error_t* e) {
    return (gm_result_ptr){ .ok = false, .u.err = e };
}

static inline gm_result_int gm_err_int(gm_error_t* e) {
    return (gm_result_int){ .ok = false, .u.err = e };
}

static inline gm_result_bool gm_err_bool(gm_error_t* e) {
    return (gm_result_bool){ .ok = false, .u.err = e };
}

static inline gm_result_size gm_err_size(gm_error_t* e) {
    return (gm_result_size){ .ok = false, .u.err = e };
}

/**
 * @brief Generic macros for result inspection
 * 
 * These work with any result type created by GM_RESULT_DEF
 */
#define GM_IS_OK(r) ((r).ok)
#define GM_IS_ERR(r) (!(r).ok)
#define GM_UNWRAP(r) ((r).u.val)
#define GM_UNWRAP_ERR(r) ((r).u.err)

/* Legacy names for migration compatibility */
#define gm_is_ok(r) GM_IS_OK(r)
#define gm_is_err(r) GM_IS_ERR(r)
#define gm_unwrap(r) GM_UNWRAP(r)
#define gm_unwrap_err(r) GM_UNWRAP_ERR(r)

/**
 * @brief Early return on error
 * 
 * If the expression evaluates to an error result, propagate it immediately.
 * Uses __auto_type (GNU extension) to work with any result type.
 */
#define GM_TRY(expr) \
    do { \
        __auto_type _result = (expr); \
        if (GM_IS_ERR(_result)) { \
            return (typeof(_result)){ .ok = false, .u.err = GM_UNWRAP_ERR(_result) }; \
        } \
    } while(0)

#endif /* GITMIND_RESULT_H */

# /Users/james/git/git-mind/core/include/gitmind/types/id.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_TYPES_ID_H
#define GITMIND_TYPES_ID_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "gitmind/result.h"

/* ID size constants */
#define GM_ID_SIZE 32           /* SHA-256 digest size in bytes */
#define GM_ID_HEX_SIZE 65       /* 32 bytes * 2 + null terminator */
#define GM_ID_HEX_CHARS 64      /* 32 bytes * 2 hex chars per byte */

/**
 * @brief 256-bit identifier (SHA-256 based)
 * 
 * Stored in big-endian format for consistent sorting
 */
typedef struct gm_id {
    uint8_t bytes[GM_ID_SIZE];  /* Big-endian SHA-256 digest (network order, as printed hex) */
} gm_id_t;

/* Define result type for ID operations */
GM_RESULT_DEF(gm_result_id, gm_id_t);

/* ID operations */
bool gm_id_equal(gm_id_t a, gm_id_t b);
int gm_id_compare(gm_id_t a, gm_id_t b);
uint32_t gm_id_hash(gm_id_t id);

/* ID creation - all can fail */
gm_result_id gm_id_from_data(const void* data, size_t len);
gm_result_id gm_id_from_string(const char* str);
gm_result_id gm_id_generate(void);  /* Random ID */

/* ID conversion */
void gm_id_to_hex(gm_id_t id, char out[GM_ID_HEX_SIZE]);

/* ID parsing (can fail) */
gm_result_id gm_id_from_hex(const char* hex);

/**
 * @brief Strongly typed IDs prevent mixing different ID types
 * 
 * Each type is distinct - you cannot accidentally pass a node_id
 * where an edge_id is expected.
 */
typedef struct { gm_id_t base; } gm_node_id_t;
typedef struct { gm_id_t base; } gm_edge_id_t;
typedef struct { gm_id_t base; } gm_graph_id_t;
typedef struct { gm_id_t base; } gm_session_id_t;
typedef struct { gm_id_t base; } gm_commit_id_t;

/* Type-safe operations (compiler enforced!) */
static inline bool gm_node_id_equal(gm_node_id_t a, gm_node_id_t b) {
    return gm_id_equal(a.base, b.base);
}

static inline bool gm_edge_id_equal(gm_edge_id_t a, gm_edge_id_t b) {
    return gm_id_equal(a.base, b.base);
}

static inline bool gm_graph_id_equal(gm_graph_id_t a, gm_graph_id_t b) {
    return gm_id_equal(a.base, b.base);
}

static inline bool gm_session_id_equal(gm_session_id_t a, gm_session_id_t b) {
    return gm_id_equal(a.base, b.base);
}

static inline bool gm_commit_id_equal(gm_commit_id_t a, gm_commit_id_t b) {
    return gm_id_equal(a.base, b.base);
}

/* Forward declarations for typed ID generation */
typedef struct gm_path gm_path_t;
typedef struct gm_edge_type gm_edge_type_t;

/* Node ID: SHA256(path) */
gm_node_id_t gm_node_id_from_path(gm_path_t path);

/* Define result type for session ID */
GM_RESULT_DEF(gm_result_session_id, gm_session_id_t);

/* Edge ID: SHA256(source || target || type) */
gm_edge_id_t gm_edge_id_from_triple(
    gm_node_id_t source,
    gm_node_id_t target, 
    gm_edge_type_t type
);

/* Session ID: Random UUID v4 */
gm_result_session_id gm_session_id_new(void);

/* Conversion helpers */
static inline void gm_node_id_to_hex(gm_node_id_t id, char out[GM_ID_HEX_SIZE]) {
    gm_id_to_hex(id.base, out);
}

static inline void gm_edge_id_to_hex(gm_edge_id_t id, char out[GM_ID_HEX_SIZE]) {
    gm_id_to_hex(id.base, out);
}

#endif /* GITMIND_TYPES_ID_H */

# /Users/james/git/git-mind/core/include/gitmind/types/path.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_TYPES_PATH_H
#define GITMIND_TYPES_PATH_H

#include "gitmind/types/string.h"
#include "gitmind/result.h"
#include <stdbool.h>

/* Forward declaration */
typedef struct gm_path_rules gm_path_rules_t;

/**
 * @brief Path state
 */
typedef enum {
    GM_PATH_STATE_RAW,       /* As provided */
    GM_PATH_STATE_CANONICAL  /* Canonicalized */
} gm_path_state_t;

/**
 * @brief Path type
 */
typedef enum {
    GM_PATH_TYPE_UNKNOWN,
    GM_PATH_TYPE_FILE,
    GM_PATH_TYPE_DIRECTORY,
    GM_PATH_TYPE_SYMLINK,
    GM_PATH_TYPE_URL,
    GM_PATH_TYPE_IDENTIFIER
} gm_path_type_t;

/**
 * @brief Path with validation state
 * 
 * Paths are always validated on creation. The validation
 * rules determine what constitutes a valid path.
 */
typedef struct gm_path {
    gm_string_t value;       /* The path string */
    char separator;          /* Path separator ('/' or '\\') */
    bool is_absolute;        /* Absolute vs relative */
    gm_path_state_t state;   /* RAW or CANONICAL */
    bool is_validated;       /* Passed validation */
    gm_path_type_t type;     /* File, directory, etc. */
} gm_path_t;

/* Define result type */
GM_RESULT_DEF(gm_result_path, gm_path_t);

/* Path creation with validation */
gm_result_path gm_path_new(const char* str);
gm_result_path gm_path_from_string(gm_string_t str);

/* Path operations */
gm_result_path gm_path_join(const gm_path_t* base, const gm_path_t* relative);
gm_result_path gm_path_dirname(const gm_path_t* path);
gm_result_path gm_path_basename(const gm_path_t* path);
gm_result_path gm_path_canonicalize(const gm_path_t* path);
gm_result_path gm_path_make_relative(const gm_path_t* path, const gm_path_t* base);

/* Path validation */
gm_result_void gm_path_validate(const gm_path_t* path, const gm_path_rules_t* rules);
bool gm_path_is_safe(const gm_path_t* path);  /* No traversal, etc. */
bool gm_path_has_extension(const gm_path_t* path, const char* ext);

/* Path comparison */
bool gm_path_equals(const gm_path_t* a, const gm_path_t* b);
bool gm_path_starts_with(const gm_path_t* path, const gm_path_t* prefix);
bool gm_path_is_child_of(const gm_path_t* path, const gm_path_t* parent);

/* Path cleanup */
void gm_path_free(gm_path_t* path);

/* Utility functions */
static inline const char* gm_path_str(const gm_path_t* path) {
    return path ? gm_string_data(&path->value) : "";
}

static inline size_t gm_path_len(const gm_path_t* path) {
    return path ? gm_string_len(&path->value) : 0;
}

static inline bool gm_path_is_empty(const gm_path_t* path) {
    return !path || gm_string_is_empty(&path->value);
}

#endif /* GITMIND_TYPES_PATH_H */

# /Users/james/git/git-mind/core/include/gitmind/types/string.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#ifndef GITMIND_TYPES_STRING_H
#define GITMIND_TYPES_STRING_H

#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include "gitmind/result.h"

/**
 * @brief Owned string with explicit length and capacity
 * 
 * ALWAYS owns its data. Use gm_string_free() when done.
 */
typedef struct gm_string {
    char* data;          /* UTF-8 data (null-terminated) */
    size_t length;       /* Length in bytes (excluding null) */
    size_t capacity;     /* Allocated capacity */
} gm_string_t;

/**
 * @brief Non-owning string view (separate type for clarity)
 * 
 * NEVER owns its data. Points to existing string.
 * The pointed-to data must outlive the view.
 */
typedef struct gm_string_view {
    const char* data;    /* Points to existing string */
    size_t length;       /* Length in bytes */
} gm_string_view_t;

/* Define result types */
GM_RESULT_DEF(gm_result_string, gm_string_t);
GM_RESULT_DEF(gm_result_string_view, gm_string_view_t);

/* String creation (always owned) */
gm_result_string gm_string_new(const char* str);
gm_result_string gm_string_new_n(const char* str, size_t len);
gm_result_string gm_string_from_owned(char* str, size_t len, size_t capacity);
gm_result_string gm_string_with_capacity(size_t capacity);

/* String view creation (never owns) */
gm_string_view_t gm_string_view(const char* str);
gm_string_view_t gm_string_view_n(const char* str, size_t len);
gm_string_view_t gm_string_view_from_string(const gm_string_t* str);

/* String operations (all bounds-checked) */
gm_result_string gm_string_copy(const gm_string_t* str);
gm_result_string gm_string_concat(const gm_string_t* a, const gm_string_t* b);
gm_result_string gm_string_substring(const gm_string_t* str, size_t start, size_t len);
gm_result_string gm_string_trim(const gm_string_t* str);

/* String modification (in-place) */
gm_result_void gm_string_append(gm_string_t* str, const char* suffix);
gm_result_void gm_string_append_n(gm_string_t* str, const char* suffix, size_t len);
gm_result_void gm_string_clear(gm_string_t* str);

/* String validation */
gm_result_void gm_string_validate_utf8(const gm_string_t* str);
bool gm_string_is_empty(const gm_string_t* str);
bool gm_string_equals(const gm_string_t* a, const gm_string_t* b);
bool gm_string_starts_with(const gm_string_t* str, const char* prefix);
bool gm_string_ends_with(const gm_string_t* str, const char* suffix);

/* String cleanup (only for owned strings) */
void gm_string_free(gm_string_t* str);

/* Utility functions */
static inline size_t gm_string_len(const gm_string_t* str) {
    return str ? str->length : 0;
}

static inline const char* gm_string_data(const gm_string_t* str) {
    return str ? str->data : "";
}

static inline bool gm_string_view_equals(gm_string_view_t a, gm_string_view_t b) {
    if (a.length != b.length) return false;
    if (a.data == b.data) return true;
    return memcmp(a.data, b.data, a.length) == 0;
}

#endif /* GITMIND_TYPES_STRING_H */

# /Users/james/git/git-mind/core/include/gitmind/utf8/validate.h
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#pragma once

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief UTF-8 validation error codes
 * 
 * Specific error types allow better error messages and security responses
 */
typedef enum {
    GM_UTF8_OK = 0,              /* Valid UTF-8 */
    GM_UTF8_ERR_OVERLONG,        /* Overlong encoding detected */
    GM_UTF8_ERR_INVALID_START,   /* Invalid start byte */
    GM_UTF8_ERR_TRUNCATED,       /* Truncated sequence */
    GM_UTF8_ERR_SURROGATE,       /* UTF-16 surrogate (D800-DFFF) */
    GM_UTF8_ERR_OUT_OF_RANGE     /* Codepoint > U+10FFFF */
} gm_utf8_error_t;

/**
 * @brief Validate complete UTF-8 buffer
 * 
 * Fast-fails on first error. Uses DFA-based validation for high performance.
 * 
 * @param buf Buffer to validate
 * @param len Length of buffer
 * @return GM_UTF8_OK or specific error code
 */
gm_utf8_error_t gm_utf8_validate(const char* buf, size_t len);

/**
 * @brief UTF-8 validation state for streaming
 * 
 * Allows validation of large inputs in chunks without buffering
 */
typedef struct {
    uint32_t state;  /* DFA state */
    uint32_t codep;  /* Current codepoint being decoded */
} gm_utf8_state_t;

/**
 * @brief Initialize streaming validation state
 * 
 * @param s State to initialize (sets to ACCEPT state)
 */
void gm_utf8_state_init(gm_utf8_state_t* s);

/**
 * @brief Validate a chunk of UTF-8 data
 * 
 * Can be called multiple times to validate large inputs.
 * Final chunk should end with state in ACCEPT for valid UTF-8.
 * 
 * @param s Validation state (modified)
 * @param buf Buffer chunk to validate
 * @param len Length of chunk
 * @return GM_UTF8_OK if chunk is valid so far, or specific error
 */
gm_utf8_error_t gm_utf8_validate_chunk(gm_utf8_state_t* s, 
                                       const char* buf, 
                                       size_t len);

/**
 * @brief Check if streaming validation is complete
 * 
 * @param s Validation state
 * @return true if in ACCEPT state (valid complete UTF-8)
 */
bool gm_utf8_state_is_complete(const gm_utf8_state_t* s);

#ifdef __cplusplus
}
#endif

# /Users/james/git/git-mind/core/src/crypto/backend.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/crypto/backend.h"
#include "gitmind/crypto/sha256.h"
#include "gitmind/crypto/random.h"
#include "gitmind/error.h"
#include <sodium.h>
#include <string.h>

/* Global backend instance */
static gm_crypto_backend_t* g_backend = NULL;

/* Libsodium backend implementation */
static int libsodium_sha256_init(gm_sha256_ctx_t* ctx) {
    crypto_hash_sha256_init((crypto_hash_sha256_state*)ctx);
    return 0;
}

static int libsodium_sha256_update(gm_sha256_ctx_t* ctx, const void* data, size_t len) {
    crypto_hash_sha256_update((crypto_hash_sha256_state*)ctx, data, len);
    return 0;
}

static int libsodium_sha256_final(gm_sha256_ctx_t* ctx, uint8_t out[GM_SHA256_DIGEST_SIZE]) {
    crypto_hash_sha256_final((crypto_hash_sha256_state*)ctx, out);
    return 0;
}

static int libsodium_sha256(const void* data, size_t len, uint8_t out[GM_SHA256_DIGEST_SIZE]) {
    crypto_hash_sha256(out, data, len);
    return 0;
}

static int libsodium_random_bytes(void* buf, size_t size) {
    randombytes_buf(buf, size);
    return 0;
}

static uint32_t libsodium_random_u32(void) {
    return randombytes_random();
}

static uint64_t libsodium_random_u64(void) {
    return ((uint64_t)randombytes_random() << 32) | randombytes_random();
}

/* Libsodium backend instance */
static gm_crypto_backend_t libsodium_backend = {
    .name = "libsodium",
    .sha256_init = libsodium_sha256_init,
    .sha256_update = libsodium_sha256_update,
    .sha256_final = libsodium_sha256_final,
    .sha256 = libsodium_sha256,
    .random_bytes = libsodium_random_bytes,
    .random_u32 = libsodium_random_u32,
    .random_u64 = libsodium_random_u64,
    .context = NULL
};

/* Test backend implementation (deterministic) */
static int test_sha256(const void* data, size_t len, uint8_t out[GM_SHA256_DIGEST_SIZE]) {
    /* Simple deterministic "hash" for testing */
    memset(out, 0, GM_SHA256_DIGEST_SIZE);
    
    /* Mix in length */
    out[0] = (uint8_t)(len & 0xFF);
    out[1] = (uint8_t)((len >> 8) & 0xFF);
    out[2] = (uint8_t)((len >> 16) & 0xFF);
    out[3] = (uint8_t)((len >> 24) & 0xFF);
    
    /* Mix in first few bytes of data */
    if (data && len > 0) {
        const uint8_t* bytes = (const uint8_t*)data;
        size_t to_copy = len < 28 ? len : 28;
        memcpy(out + 4, bytes, to_copy);
    }
    
    return 0;
}

static int test_sha256_init(gm_sha256_ctx_t* ctx) {
    /* Clear context */
    memset(ctx, 0, sizeof(*ctx));
    return 0;
}

static int test_sha256_update(gm_sha256_ctx_t* ctx, const void* data, size_t len) {
    /* For test backend, just track total length */
    (void)data;  /* Unused in test implementation */
    uint64_t* total = (uint64_t*)ctx;
    *total += len;
    return 0;
}

static int test_sha256_final(gm_sha256_ctx_t* ctx, uint8_t out[GM_SHA256_DIGEST_SIZE]) {
    /* Output based on total length */
    uint64_t* total = (uint64_t*)ctx;
    memset(out, 0, GM_SHA256_DIGEST_SIZE);
    memcpy(out, total, sizeof(*total));
    return 0;
}

static uint32_t test_counter = 0;

static int test_random_bytes(void* buf, size_t size) {
    /* Fill with incrementing pattern */
    uint8_t* bytes = (uint8_t*)buf;
    for (size_t i = 0; i < size; i++) {
        bytes[i] = (uint8_t)(test_counter++ & 0xFF);
    }
    return 0;
}

static uint32_t test_random_u32(void) {
    return test_counter++;
}

static uint64_t test_random_u64(void) {
    uint64_t result = test_counter;
    test_counter += 2;
    return result;
}

/* Test backend instance */
static gm_crypto_backend_t test_backend = {
    .name = "test",
    .sha256_init = test_sha256_init,
    .sha256_update = test_sha256_update,
    .sha256_final = test_sha256_final,
    .sha256 = test_sha256,
    .random_bytes = test_random_bytes,
    .random_u32 = test_random_u32,
    .random_u64 = test_random_u64,
    .context = &test_counter
};

/* Get libsodium backend */
gm_crypto_backend_t* gm_crypto_backend_libsodium(void) {
    return &libsodium_backend;
}

/* Get test backend */
gm_crypto_backend_t* gm_crypto_backend_test(void) {
    /* Reset counter for reproducibility */
    test_counter = 0;
    return &test_backend;
}

/* Set current backend */
gm_result_backend gm_crypto_set_backend(gm_crypto_backend_t* backend) {
    if (!backend) {
        return (gm_result_backend){
            .ok = false,
            .u.err = GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL backend")
        };
    }
    
    /* Validate backend has all required functions */
    if (!backend->sha256_init || !backend->sha256_update || 
        !backend->sha256_final || !backend->sha256 ||
        !backend->random_bytes || !backend->random_u32 || 
        !backend->random_u64) {
        return (gm_result_backend){
            .ok = false,
            .u.err = GM_ERROR(GM_ERR_INVALID_ARGUMENT, 
                             "Backend missing required functions")
        };
    }
    
    g_backend = backend;
    return (gm_result_backend){ .ok = true, .u.val = backend };
}

/* Get current backend */
gm_crypto_backend_t* gm_crypto_get_backend(void) {
    return g_backend;
}

/* Initialize crypto subsystem */
gm_result_void gm_crypto_init(void) {
    /* Initialize libsodium if not already done */
    static bool sodium_initialized = false;
    if (!sodium_initialized) {
        if (sodium_init() < 0) {
            return gm_err_void(GM_ERROR(GM_ERR_UNKNOWN, 
                                       "Failed to initialize libsodium"));
        }
        sodium_initialized = true;
    }
    
    /* Set default backend if none set */
    if (!g_backend) {
        gm_result_backend result = gm_crypto_set_backend(&libsodium_backend);
        if (GM_IS_ERR(result)) {
            return gm_err_void(GM_UNWRAP_ERR(result));
        }
    }
    
    return gm_ok_void();
}

/* Cleanup crypto subsystem */
gm_result_void gm_crypto_cleanup(void) {
    g_backend = NULL;
    return gm_ok_void();
}

# /Users/james/git/git-mind/core/src/crypto/random.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/crypto/random.h"
#include "gitmind/crypto/backend.h"
#include "gitmind/error.h"
#include <sodium.h>

/* Helper to create error result for u32 */
static inline gm_result_u32 gm_err_u32(gm_error_t* e) {
    return (gm_result_u32){ .ok = false, .u.err = e };
}

/* Helper to create error result for u64 */
static inline gm_result_u64 gm_err_u64(gm_error_t* e) {
    return (gm_result_u64){ .ok = false, .u.err = e };
}

gm_result_void gm_random_bytes(void* buf, size_t size) {
    if (!buf) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL buffer"));
    }
    if (size == 0) {
        return gm_ok_void();
    }
    
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->random_bytes) {
        backend->random_bytes(buf, size);
        return gm_ok_void();
    }
    
    /* Fallback to direct libsodium */
    randombytes_buf(buf, size);
    return gm_ok_void();
}

gm_result_u32 gm_random_u32(void) {
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->random_u32) {
        return (gm_result_u32){ .ok = true, .u.val = backend->random_u32() };
    }
    
    /* Fallback to direct libsodium */
    return (gm_result_u32){ .ok = true, .u.val = randombytes_random() };
}

gm_result_u64 gm_random_u64(void) {
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->random_u64) {
        return (gm_result_u64){ .ok = true, .u.val = backend->random_u64() };
    }
    
    /* Fallback to direct libsodium */
    uint64_t val;
    randombytes_buf(&val, sizeof(val));
    return (gm_result_u64){ .ok = true, .u.val = val };
}

# /Users/james/git/git-mind/core/src/crypto/sha256.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/crypto/sha256.h"
#include "gitmind/crypto/backend.h"
#include "gitmind/error.h"
#include <sodium.h>
#include <string.h>
#include <assert.h>

/* Ensure our context size is sufficient */
_Static_assert(sizeof(crypto_hash_sha256_state) <= sizeof(gm_sha256_ctx_t),
               "gm_sha256_ctx_t too small for libsodium state");

gm_result_void gm_sha256(const void* data, size_t len, uint8_t out[GM_SHA256_DIGEST_SIZE]) {
    if (!data && len > 0) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL data with non-zero length"));
    }
    if (!out) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL output buffer"));
    }
    
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->sha256) {
        backend->sha256(data, len, out);
        return gm_ok_void();
    }
    
    /* Fallback to direct libsodium */
    crypto_hash_sha256(out, data, len);
    return gm_ok_void();
}

gm_result_void gm_sha256_init(gm_sha256_ctx_t* ctx) {
    if (!ctx) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL context"));
    }
    
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->sha256_init) {
        backend->sha256_init(ctx);
        return gm_ok_void();
    }
    
    /* Fallback to direct libsodium */
    crypto_hash_sha256_state* state = (crypto_hash_sha256_state*)ctx;
    crypto_hash_sha256_init(state);
    return gm_ok_void();
}

gm_result_void gm_sha256_update(gm_sha256_ctx_t* ctx, const void* data, size_t len) {
    if (!ctx) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL context"));
    }
    if (!data && len > 0) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL data with non-zero length"));
    }
    
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->sha256_update) {
        backend->sha256_update(ctx, data, len);
        return gm_ok_void();
    }
    
    /* Fallback to direct libsodium */
    crypto_hash_sha256_state* state = (crypto_hash_sha256_state*)ctx;
    crypto_hash_sha256_update(state, data, len);
    return gm_ok_void();
}

gm_result_void gm_sha256_final(gm_sha256_ctx_t* ctx, uint8_t out[GM_SHA256_DIGEST_SIZE]) {
    if (!ctx) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL context"));
    }
    if (!out) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL output buffer"));
    }
    
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    
    /* Use backend if available */
    if (backend && backend->sha256_final) {
        backend->sha256_final(ctx, out);
        return gm_ok_void();
    }
    
    /* Fallback to direct libsodium */
    crypto_hash_sha256_state* state = (crypto_hash_sha256_state*)ctx;
    crypto_hash_sha256_final(state, out);
    return gm_ok_void();
}

# /Users/james/git/git-mind/core/src/error/error.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/error.h"
#include "gitmind/result.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Helper to set error message with SSO */
static void set_error_message(gm_error_t* err, const char* fmt, va_list args) {
    /* Need to copy va_list to use it twice */
    va_list args_copy;
    va_copy(args_copy, args);
    
    /* First, format to a temporary buffer to get the length */
    char temp[1024];
    int len = vsnprintf(temp, sizeof(temp), fmt, args);
    
    if (len < 0) {
        /* Formatting error - use a default message */
        strcpy(err->msg.small, "Error formatting failed");
        err->len = strlen(err->msg.small);
        err->heap_alloc = false;
        va_end(args_copy);
        return;
    }
    
    err->len = (uint16_t)len;
    
    if (len < GM_ERROR_SMALL_SIZE - 1) {
        /* Small string - store inline (use the already formatted temp) */
        memcpy(err->msg.small, temp, len + 1);
        err->heap_alloc = false;
    } else {
        /* Large string - allocate on heap */
        err->msg.heap = malloc(len + 1);
        if (err->msg.heap) {
            vsnprintf(err->msg.heap, len + 1, fmt, args_copy);
            err->heap_alloc = true;
        } else {
            /* Allocation failed - truncate to small buffer */
            memcpy(err->msg.small, temp, GM_ERROR_SMALL_SIZE - 1);
            err->msg.small[GM_ERROR_SMALL_SIZE - 1] = '\0';
            err->len = GM_ERROR_SMALL_SIZE - 1;
            err->heap_alloc = false;
        }
    }
    
    va_end(args_copy);
}

/* Get message pointer (handles SSO) */
static const char* get_error_message(const gm_error_t* err) {
    return err->heap_alloc ? err->msg.heap : err->msg.small;
}

/* Create new error with formatted message */
gm_error_t* gm_error_new(int32_t code, const char* fmt, ...) {
    gm_error_t* err = malloc(sizeof(gm_error_t));
    if (!err) {
        return NULL; /* Can't allocate error to report allocation failure */
    }
    
    memset(err, 0, sizeof(gm_error_t));
    err->code = code;
    
    /* Format message with SSO */
    va_list args;
    va_start(args, fmt);
    set_error_message(err, fmt, args);
    va_end(args);
    
    return err;
}

/* Create error with source location */
gm_error_t* gm_error_new_at(
    const char* file, 
    int line, 
    const char* func,
    int32_t code, 
    const char* fmt, 
    ...
) {
    gm_error_t* err = malloc(sizeof(gm_error_t));
    if (!err) {
        return NULL;
    }
    
    memset(err, 0, sizeof(gm_error_t));
    err->code = code;
    err->file = file; /* Static string, no copy needed */
    err->line = line;
    err->func = func; /* Static string, no copy needed */
    
    /* Format message with SSO */
    va_list args;
    va_start(args, fmt);
    set_error_message(err, fmt, args);
    va_end(args);
    
    return err;
}

/* Add context to existing error */
gm_error_t* gm_error_wrap(
    gm_error_t* cause,
    int32_t code,
    const char* fmt,
    ...
) {
    gm_error_t* err = malloc(sizeof(gm_error_t));
    if (!err) {
        /* Can't wrap, at least don't leak the cause */
        gm_error_free(cause);
        return NULL;
    }
    
    memset(err, 0, sizeof(gm_error_t));
    err->code = code;
    err->cause = cause; /* Take ownership */
    
    /* Format message with SSO */
    va_list args;
    va_start(args, fmt);
    set_error_message(err, fmt, args);
    va_end(args);
    
    return err;
}

/* Free error and its cause chain */
void gm_error_free(gm_error_t* error) {
    if (!error) {
        return;
    }
    
    /* Free heap-allocated message if present */
    if (error->heap_alloc && error->msg.heap) {
        free(error->msg.heap);
    }
    
    /* Free cause chain recursively */
    if (error->cause) {
        gm_error_free(error->cause);
    }
    
    /* Free any context data if present */
    if (error->context) {
        free(error->context);
    }
    
    free(error);
}

/* Format error chain as string */
char* gm_error_format(const gm_error_t* error) {
    if (!error) {
        return strdup("(no error)");
    }
    
    /* Count errors in chain */
    size_t count = 0;
    const gm_error_t* e = error;
    while (e) {
        count++;
        e = e->cause;
    }
    
    /* Allocate buffer (generously) */
    size_t buf_size = count * 512;
    char* buffer = malloc(buf_size);
    if (!buffer) {
        return strdup("(error formatting failed)");
    }
    
    /* Format each error */
    size_t offset = 0;
    e = error;
    while (e && offset < buf_size - 1) {
        int written;
        
        const char* msg = get_error_message(e);
        
        if (e->file && e->func) {
            written = snprintf(
                buffer + offset, 
                buf_size - offset,
                "[%d] %s (%s:%d in %s)\n",
                e->code,
                msg,
                e->file,
                e->line,
                e->func
            );
        } else {
            written = snprintf(
                buffer + offset, 
                buf_size - offset,
                "[%d] %s\n",
                e->code,
                msg
            );
        }
        
        if (written > 0 && (size_t)written < buf_size - offset) {
            offset += written;
        } else {
            break;
        }
        
        e = e->cause;
        if (e && offset < buf_size - 1) {
            written = snprintf(
                buffer + offset,
                buf_size - offset,
                "  caused by: "
            );
            if (written > 0 && (size_t)written < buf_size - offset) {
                offset += written;
            }
        }
    }
    
    buffer[buf_size - 1] = '\0';
    return buffer;
}

/* Print error chain to stderr */
void gm_error_print(const gm_error_t* error) {
    char* formatted = gm_error_format(error);
    if (formatted) {
        fprintf(stderr, "%s", formatted);
        free(formatted);
    }
}

# /Users/james/git/git-mind/core/src/types/id.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/id.h"
#include "gitmind/error.h"
#include "gitmind/crypto/sha256.h"
#include "gitmind/crypto/random.h"
#include <string.h>
#include <stdio.h>
#include <sodium.h>

/* Compare two IDs */
bool gm_id_equal(gm_id_t a, gm_id_t b) {
    return memcmp(a.bytes, b.bytes, GM_ID_SIZE) == 0;
}

/* Compare IDs for ordering */
int gm_id_compare(gm_id_t a, gm_id_t b) {
    return memcmp(a.bytes, b.bytes, GM_ID_SIZE);
}

/* Hash function for hash tables using SipHash-2-4 */
uint32_t gm_id_hash(gm_id_t id) {
    /* Use SipHash-2-4 with a fixed key for deterministic hashing */
    static const uint8_t siphash_key[crypto_shorthash_siphash24_KEYBYTES] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
    
    /* SipHash produces 8-byte output */
    uint8_t hash_output[crypto_shorthash_siphash24_BYTES];
    
    /* Compute SipHash-2-4 of the ID bytes */
    crypto_shorthash_siphash24(
        hash_output,           /* output buffer */
        id.bytes,             /* input data */
        GM_ID_SIZE,           /* input length */
        siphash_key           /* 128-bit key */
    );
    
    /* Convert 8-byte output to uint64_t */
    uint64_t hash64;
    memcpy(&hash64, hash_output, sizeof(hash64));
    
    /* Mix upper and lower halves for better distribution */
    return (uint32_t)(hash64 ^ (hash64 >> 32));
}

/* Helper to create error result for ID */
static inline gm_result_id gm_err_id(gm_error_t* e) {
    return (gm_result_id){ .ok = false, .u.err = e };
}

/* Create ID from data */
gm_result_id gm_id_from_data(const void* data, size_t len) {
    if (!data) {
        return gm_err_id(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL data"));
    }
    
    gm_id_t id;
    gm_result_void result = gm_sha256(data, len, id.bytes);
    if (GM_IS_ERR(result)) {
        return gm_err_id(GM_UNWRAP_ERR(result));
    }
    
    return (gm_result_id){ .ok = true, .u.val = id };
}

/* Create ID from string */
gm_result_id gm_id_from_string(const char* str) {
    if (!str) {
        return gm_err_id(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL string"));
    }
    return gm_id_from_data(str, strlen(str));
}

/* Generate random ID */
gm_result_id gm_id_generate(void) {
    gm_id_t id;
    gm_result_void result = gm_random_bytes(id.bytes, GM_ID_SIZE);
    if (GM_IS_ERR(result)) {
        return gm_err_id(GM_UNWRAP_ERR(result));
    }
    
    return (gm_result_id){ .ok = true, .u.val = id };
}

/* Convert ID to hex string */
void gm_id_to_hex(gm_id_t id, char out[GM_ID_HEX_SIZE]) {
    static const char hex[] = "0123456789abcdef";
    
    for (int i = 0; i < GM_ID_SIZE; i++) {
        out[i * 2]     = hex[id.bytes[i] >> 4];
        out[i * 2 + 1] = hex[id.bytes[i] & 0x0F];
    }
    out[GM_ID_HEX_CHARS] = '\0';
}

/* Parse hex string to ID */
gm_result_id gm_id_from_hex(const char* hex) {
    gm_id_t id;
    memset(&id, 0, sizeof(id));
    
    if (!hex || strlen(hex) != GM_ID_HEX_CHARS) {
        return (gm_result_id){
            .ok = false,
            .u.err = GM_ERROR(GM_ERR_INVALID_FORMAT, 
                             "Invalid hex ID: must be %d characters", GM_ID_HEX_CHARS)
        };
    }
    
    for (int i = 0; i < GM_ID_SIZE; i++) {
        unsigned int byte;
        if (sscanf(hex + i * 2, "%2x", &byte) != 1) {
            return (gm_result_id){
                .ok = false,
                .u.err = GM_ERROR(GM_ERR_INVALID_FORMAT,
                                 "Invalid hex character at position %d", i * 2)
            };
        }
        id.bytes[i] = (uint8_t)byte;
    }
    
    return (gm_result_id){ .ok = true, .u.val = id };
}

/* Helper to create error result for session ID */
static inline gm_result_session_id gm_err_session_id(gm_error_t* e) {
    return (gm_result_session_id){ .ok = false, .u.err = e };
}

/* Generate session ID */
gm_result_session_id gm_session_id_new(void) {
    gm_result_id result = gm_id_generate();
    if (GM_IS_ERR(result)) {
        return gm_err_session_id(GM_UNWRAP_ERR(result));
    }
    
    gm_session_id_t sid;
    sid.base = GM_UNWRAP(result);
    return (gm_result_session_id){ .ok = true, .u.val = sid };
}

# /Users/james/git/git-mind/core/src/types/path.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/path.h"
#include "gitmind/error.h"
#include <string.h>
#include <stdlib.h>

/* Path constants */
#define PATH_SEP_UNIX '/'
#define PATH_SEP_WIN '\\'
#define PATH_CURRENT_DIR "."
#define PATH_PARENT_DIR ".."
#define PATH_MAX_COMPONENTS 255

/* Helper to create error result for path */
static inline gm_result_path gm_err_path(gm_error_t* e) {
    return (gm_result_path){ .ok = false, .u.err = e };
}

/* Helper to create success result for path */
static inline gm_result_path gm_ok_path(gm_path_t p) {
    return (gm_result_path){ .ok = true, .u.val = p };
}

/* Detect path separator */
static char detect_separator(const char* str) {
    /* Look for first separator */
    const char* unix_sep = strchr(str, PATH_SEP_UNIX);
    const char* win_sep = strchr(str, PATH_SEP_WIN);
    
    if (unix_sep && !win_sep) return PATH_SEP_UNIX;
    if (win_sep && !unix_sep) return PATH_SEP_WIN;
    if (unix_sep && win_sep) {
        /* Use whichever comes first */
        return (unix_sep < win_sep) ? PATH_SEP_UNIX : PATH_SEP_WIN;
    }
    
    /* Default to system separator */
#ifdef _WIN32
    return PATH_SEP_WIN;
#else
    return PATH_SEP_UNIX;
#endif
}

/* Check if path is absolute */
static bool is_absolute_path(const char* str, char separator) {
    if (!str || !*str) return false;
    
    if (separator == PATH_SEP_UNIX) {
        return str[0] == PATH_SEP_UNIX;
    } else {
        /* Windows: C:\ or \\server\share */
        if (str[0] == PATH_SEP_WIN && str[1] == PATH_SEP_WIN) {
            return true;  /* UNC path */
        }
        if (str[1] == ':' && str[2] == PATH_SEP_WIN) {
            return true;  /* Drive letter */
        }
    }
    return false;
}

/* Basic path validation (no traversal check yet) */
static bool validate_path_basic(const char* str) {
    if (!str) return false;
    
    size_t len = strlen(str);
    if (len == 0) return true;  /* Empty path is valid */
    
    /* Check for null bytes */
    for (size_t i = 0; i < len; i++) {
        if (str[i] == '\0') return false;
    }
    
    /* More validation can be added here */
    return true;
}

/* Create new path from string */
gm_result_path gm_path_new(const char* str) {
    if (!str) {
        str = "";  /* Treat NULL as empty path */
    }
    
    /* Basic validation */
    if (!validate_path_basic(str)) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_PATH, 
                                   "Invalid path format"));
    }
    
    /* Create string copy */
    gm_result_string str_result = gm_string_new(str);
    if (GM_IS_ERR(str_result)) {
        return gm_err_path(GM_UNWRAP_ERR(str_result));
    }
    
    gm_path_t path;
    path.value = GM_UNWRAP(str_result);
    path.separator = detect_separator(str);
    path.is_absolute = is_absolute_path(str, path.separator);
    path.state = GM_PATH_STATE_RAW;
    path.is_validated = true;  /* Basic validation passed */
    path.type = GM_PATH_TYPE_UNKNOWN;
    
    return gm_ok_path(path);
}

/* Create path from existing string (takes ownership) */
gm_result_path gm_path_from_string(gm_string_t str) {
    const char* data = gm_string_data(&str);
    
    /* Basic validation */
    if (!validate_path_basic(data)) {
        gm_string_free(&str);
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_PATH, 
                                   "Invalid path format"));
    }
    
    gm_path_t path;
    path.value = str;  /* Take ownership */
    path.separator = detect_separator(data);
    path.is_absolute = is_absolute_path(data, path.separator);
    path.state = GM_PATH_STATE_RAW;
    path.is_validated = true;
    path.type = GM_PATH_TYPE_UNKNOWN;
    
    return gm_ok_path(path);
}

/* Join two paths */
gm_result_path gm_path_join(const gm_path_t* base, const gm_path_t* relative) {
    if (!base) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL base path"));
    }
    if (!relative) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL relative path"));
    }
    
    /* If relative is absolute, return copy of it */
    if (relative->is_absolute) {
        return gm_path_new(gm_path_str(relative));
    }
    
    /* If base is empty, return copy of relative */
    if (gm_path_is_empty(base)) {
        return gm_path_new(gm_path_str(relative));
    }
    
    /* If relative is empty, return copy of base */
    if (gm_path_is_empty(relative)) {
        return gm_path_new(gm_path_str(base));
    }
    
    /* Join with separator */
    const char* base_str = gm_path_str(base);
    size_t base_len = gm_path_len(base);
    bool needs_sep = (base_len > 0 && 
                     base_str[base_len - 1] != base->separator);
    
    /* Create joined string */
    gm_result_string result;
    if (needs_sep) {
        /* Need to add separator */
        char sep_str[2] = { base->separator, '\0' };
        gm_result_string with_sep = gm_string_concat(&base->value, 
                                                     &(gm_string_t){
                                                         .data = sep_str,
                                                         .length = 1,
                                                         .capacity = 2
                                                     });
        if (GM_IS_ERR(with_sep)) {
            return gm_err_path(GM_UNWRAP_ERR(with_sep));
        }
        gm_string_t temp = GM_UNWRAP(with_sep);
        result = gm_string_concat(&temp, &relative->value);
        gm_string_free(&temp);
    } else {
        result = gm_string_concat(&base->value, &relative->value);
    }
    
    if (GM_IS_ERR(result)) {
        return gm_err_path(GM_UNWRAP_ERR(result));
    }
    
    return gm_path_from_string(GM_UNWRAP(result));
}

/* Extract directory name */
gm_result_path gm_path_dirname(const gm_path_t* path) {
    if (!path) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL path"));
    }
    
    const char* str = gm_path_str(path);
    size_t len = gm_path_len(path);
    
    /* Empty path returns "." */
    if (len == 0) {
        return gm_path_new(PATH_CURRENT_DIR);
    }
    
    /* Find last separator */
    size_t last_sep = len;
    for (size_t i = len; i > 0; i--) {
        if (str[i - 1] == path->separator) {
            last_sep = i - 1;
            break;
        }
    }
    
    /* No separator found */
    if (last_sep == len) {
        return gm_path_new(PATH_CURRENT_DIR);
    }
    
    /* Root directory special case */
    if (last_sep == 0 && path->is_absolute) {
        char root[2] = { path->separator, '\0' };
        return gm_path_new(root);
    }
    
    /* Extract directory part */
    gm_result_string dir_result = gm_string_substring(&path->value, 0, last_sep);
    if (GM_IS_ERR(dir_result)) {
        return gm_err_path(GM_UNWRAP_ERR(dir_result));
    }
    
    return gm_path_from_string(GM_UNWRAP(dir_result));
}

/* Extract base name */
gm_result_path gm_path_basename(const gm_path_t* path) {
    if (!path) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL path"));
    }
    
    const char* str = gm_path_str(path);
    size_t len = gm_path_len(path);
    
    /* Empty path returns empty */
    if (len == 0) {
        return gm_path_new("");
    }
    
    /* Find last separator */
    size_t start = 0;
    for (size_t i = len; i > 0; i--) {
        if (str[i - 1] == path->separator) {
            start = i;
            break;
        }
    }
    
    /* Extract base name */
    gm_result_string base_result = gm_string_substring(&path->value, start, len - start);
    if (GM_IS_ERR(base_result)) {
        return gm_err_path(GM_UNWRAP_ERR(base_result));
    }
    
    return gm_path_from_string(GM_UNWRAP(base_result));
}

/* Canonicalize path (remove . and .. components) */
gm_result_path gm_path_canonicalize(const gm_path_t* path) {
    if (!path) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL path"));
    }
    
    /* For now, just return a copy marked as canonical */
    /* Full implementation would resolve . and .. */
    gm_result_path result = gm_path_new(gm_path_str(path));
    if (GM_IS_OK(result)) {
        gm_path_t canonical = GM_UNWRAP(result);
        canonical.state = GM_PATH_STATE_CANONICAL;
        return gm_ok_path(canonical);
    }
    
    return result;
}

/* Make path relative to base */
gm_result_path gm_path_make_relative(const gm_path_t* path, const gm_path_t* base) {
    if (!path || !base) {
        return gm_err_path(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL path"));
    }
    
    /* For now, return error - full implementation needed */
    return gm_err_path(GM_ERROR(GM_ERR_NOT_IMPLEMENTED, 
                               "make_relative not yet implemented"));
}

/* Validate path with rules */
gm_result_void gm_path_validate(const gm_path_t* path, const gm_path_rules_t* rules) {
    if (!path) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL path"));
    }
    
    /* Rules not yet defined, suppress unused warning */
    (void)rules;
    
    /* Rules not yet defined, just check basic safety */
    if (!gm_path_is_safe(path)) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_PATH, 
                                   "Path contains traversal sequences"));
    }
    
    return gm_ok_void();
}

/* Check if path is safe (no directory traversal) */
bool gm_path_is_safe(const gm_path_t* path) {
    if (!path) return false;
    
    const char* str = gm_path_str(path);
    
    /* Check for .. sequences */
    if (strstr(str, "..")) {
        return false;
    }
    
    /* More checks can be added here */
    return true;
}

/* Check if path has extension */
bool gm_path_has_extension(const gm_path_t* path, const char* ext) {
    if (!path || !ext) return false;
    
    size_t len = gm_path_len(path);
    size_t ext_len = strlen(ext);
    
    if (ext_len >= len) return false;
    
    /* Check if ends with extension */
    return gm_string_ends_with(&path->value, ext);
}

/* Compare paths */
bool gm_path_equals(const gm_path_t* a, const gm_path_t* b) {
    if (a == b) return true;
    if (!a || !b) return false;
    
    /* For now, simple string comparison */
    /* Full implementation would canonicalize first */
    return gm_string_equals(&a->value, &b->value);
}

/* Check if path starts with prefix */
bool gm_path_starts_with(const gm_path_t* path, const gm_path_t* prefix) {
    if (!path || !prefix) return false;
    
    return gm_string_starts_with(&path->value, gm_path_str(prefix));
}

/* Check if path is child of parent */
bool gm_path_is_child_of(const gm_path_t* path, const gm_path_t* parent) {
    if (!path || !parent) return false;
    
    /* Must start with parent */
    if (!gm_path_starts_with(path, parent)) {
        return false;
    }
    
    /* And have more components */
    size_t parent_len = gm_path_len(parent);
    size_t path_len = gm_path_len(path);
    
    if (path_len <= parent_len) {
        return false;
    }
    
    /* Check for separator after parent */
    const char* path_str = gm_path_str(path);
    return path_str[parent_len] == path->separator;
}

/* Free path */
void gm_path_free(gm_path_t* path) {
    if (path) {
        gm_string_free(&path->value);
        /* Reset other fields */
        path->separator = '/';
        path->is_absolute = false;
        path->state = GM_PATH_STATE_RAW;
        path->is_validated = false;
        path->type = GM_PATH_TYPE_UNKNOWN;
    }
}

# /Users/james/git/git-mind/core/src/types/string.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/string.h"
#include <string.h>

/* String views - these don't allocate memory */

/* Create string view */
gm_string_view_t gm_string_view(const char* str) {
    if (!str) {
        return (gm_string_view_t){ .data = "", .length = 0 };
    }
    return gm_string_view_n(str, strlen(str));
}

/* Create string view with length */
gm_string_view_t gm_string_view_n(const char* str, size_t len) {
    return (gm_string_view_t){ .data = str, .length = len };
}

/* Create view from string */
gm_string_view_t gm_string_view_from_string(const gm_string_t* str) {
    if (!str) {
        return (gm_string_view_t){ .data = "", .length = 0 };
    }
    return (gm_string_view_t){ .data = str->data, .length = str->length };
}

/* Comparison functions - these don't allocate memory */

/* Check if string is empty */
bool gm_string_is_empty(const gm_string_t* str) {
    return !str || str->length == 0;
}

/* Compare strings */
bool gm_string_equals(const gm_string_t* a, const gm_string_t* b) {
    if (a == b) return true;
    if (!a || !b) return false;
    if (a->length != b->length) return false;
    return memcmp(a->data, b->data, a->length) == 0;
}

/* Check prefix */
bool gm_string_starts_with(const gm_string_t* str, const char* prefix) {
    if (!str || !prefix) return false;
    size_t prefix_len = strlen(prefix);
    if (prefix_len > str->length) return false;
    return memcmp(str->data, prefix, prefix_len) == 0;
}

/* Check suffix */
bool gm_string_ends_with(const gm_string_t* str, const char* suffix) {
    if (!str || !suffix) return false;
    size_t suffix_len = strlen(suffix);
    if (suffix_len > str->length) return false;
    return memcmp(str->data + str->length - suffix_len, suffix, suffix_len) == 0;
}

# /Users/james/git/git-mind/core/src/types/string_core.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/string.h"
#include "gitmind/error.h"
#include <stdlib.h>
#include <string.h>

/* Minimum capacity for string growth */
#define MIN_CAPACITY 16
#define GROWTH_FACTOR 2

/* Helper to calculate next capacity */
static size_t next_capacity(size_t current, size_t needed) {
    size_t new_cap = current * GROWTH_FACTOR;
    if (new_cap < needed) {
        new_cap = needed;
    }
    if (new_cap < MIN_CAPACITY) {
        new_cap = MIN_CAPACITY;
    }
    return new_cap;
}

/* Helper to create error result for string */
static inline gm_result_string gm_err_string(gm_error_t* e) {
    return (gm_result_string){ .ok = false, .u.err = e };
}

/* Create new string from C string */
gm_result_string gm_string_new(const char* str) {
    if (!str) {
        return gm_string_new_n("", 0);
    }
    return gm_string_new_n(str, strlen(str));
}

/* Create new string with specific length */
gm_result_string gm_string_new_n(const char* str, size_t len) {
    gm_string_t s;
    s.length = len;
    s.capacity = len + 1; /* +1 for null terminator */
    
    s.data = malloc(s.capacity);
    if (!s.data) {
        return (gm_result_string){
            .ok = false,
            .u.err = GM_ERROR(GM_ERR_OUT_OF_MEMORY, 
                             "Failed to allocate %zu bytes", s.capacity)
        };
    }
    
    if (str && len > 0) {
        memcpy(s.data, str, len);
    }
    s.data[len] = '\0';
    
    return (gm_result_string){ .ok = true, .u.val = s };
}

/* Create string with pre-allocated capacity */
gm_result_string gm_string_with_capacity(size_t capacity) {
    gm_string_t s;
    s.length = 0;
    s.capacity = capacity > 0 ? capacity : MIN_CAPACITY;
    
    s.data = malloc(s.capacity);
    if (!s.data) {
        return (gm_result_string){
            .ok = false,
            .u.err = GM_ERROR(GM_ERR_OUT_OF_MEMORY,
                             "Failed to allocate %zu bytes", s.capacity)
        };
    }
    
    s.data[0] = '\0';
    return (gm_result_string){ .ok = true, .u.val = s };
}

/* Create string from owned buffer */
gm_result_string gm_string_from_owned(char* str, size_t len, size_t capacity) {
    if (!str || capacity < len + 1) {
        return (gm_result_string){
            .ok = false,
            .u.err = GM_ERROR(GM_ERR_INVALID_ARGUMENT,
                             "Invalid owned string parameters")
        };
    }
    
    gm_string_t s;
    s.data = str;
    s.length = len;
    s.capacity = capacity;
    
    return (gm_result_string){ .ok = true, .u.val = s };
}

/* Copy string */
gm_result_string gm_string_copy(const gm_string_t* str) {
    if (!str) {
        return gm_string_new("");
    }
    return gm_string_new_n(str->data, str->length);
}

/* Concatenate strings */
gm_result_string gm_string_concat(const gm_string_t* a, const gm_string_t* b) {
    size_t len_a = a ? a->length : 0;
    size_t len_b = b ? b->length : 0;
    size_t total = len_a + len_b;
    
    gm_result_string result = gm_string_with_capacity(total + 1);
    if (GM_IS_ERR(result)) {
        return result;
    }
    
    gm_string_t s = GM_UNWRAP(result);
    if (a && len_a > 0) {
        memcpy(s.data, a->data, len_a);
    }
    if (b && len_b > 0) {
        memcpy(s.data + len_a, b->data, len_b);
    }
    s.data[total] = '\0';
    s.length = total;
    
    return (gm_result_string){ .ok = true, .u.val = s };
}

/* Append to string */
gm_result_void gm_string_append(gm_string_t* str, const char* suffix) {
    if (!suffix) {
        return gm_ok_void();
    }
    return gm_string_append_n(str, suffix, strlen(suffix));
}

/* Append with length */
gm_result_void gm_string_append_n(gm_string_t* str, const char* suffix, size_t len) {
    if (!str) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL string"));
    }
    if (!suffix || len == 0) {
        return gm_ok_void();
    }
    
    size_t new_len = str->length + len;
    if (new_len + 1 > str->capacity) {
        size_t new_cap = next_capacity(str->capacity, new_len + 1);
        char* new_data = realloc(str->data, new_cap);
        if (!new_data) {
            return gm_err_void(GM_ERROR(GM_ERR_OUT_OF_MEMORY,
                                       "Failed to grow string"));
        }
        str->data = new_data;
        str->capacity = new_cap;
    }
    
    memcpy(str->data + str->length, suffix, len);
    str->length = new_len;
    str->data[new_len] = '\0';
    
    return gm_ok_void();
}

/* Clear string contents */
gm_result_void gm_string_clear(gm_string_t* str) {
    if (!str) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL string"));
    }
    
    str->length = 0;
    if (str->data) {
        str->data[0] = '\0';
    }
    
    return gm_ok_void();
}

/* Extract substring */
gm_result_string gm_string_substring(const gm_string_t* str, size_t start, size_t len) {
    if (!str) {
        return gm_err_string(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL string"));
    }
    
    /* Bounds check */
    if (start > str->length) {
        return gm_err_string(GM_ERROR(GM_ERR_INVALID_LENGTH, 
                                     "Start position %zu exceeds string length %zu", 
                                     start, str->length));
    }
    
    /* Adjust length if it would exceed string bounds */
    size_t available = str->length - start;
    if (len > available) {
        len = available;
    }
    
    return gm_string_new_n(str->data + start, len);
}

/* Trim whitespace from both ends */
gm_result_string gm_string_trim(const gm_string_t* str) {
    if (!str) {
        return gm_err_string(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL string"));
    }
    
    /* Empty string returns empty string */
    if (str->length == 0) {
        return gm_string_new("");
    }
    
    /* Find first non-whitespace character */
    size_t start = 0;
    while (start < str->length && 
           (str->data[start] == ' ' || str->data[start] == '\t' || 
            str->data[start] == '\n' || str->data[start] == '\r')) {
        start++;
    }
    
    /* All whitespace? Return empty string */
    if (start == str->length) {
        return gm_string_new("");
    }
    
    /* Find last non-whitespace character */
    size_t end = str->length - 1;
    while (end > start && 
           (str->data[end] == ' ' || str->data[end] == '\t' || 
            str->data[end] == '\n' || str->data[end] == '\r')) {
        end--;
    }
    
    /* Extract the trimmed portion */
    size_t trimmed_len = end - start + 1;
    return gm_string_new_n(str->data + start, trimmed_len);
}

/* Free string */
void gm_string_free(gm_string_t* str) {
    if (str && str->data) {
        free(str->data);
        str->data = NULL;
        str->length = 0;
        str->capacity = 0;
    }
}

# /Users/james/git/git-mind/core/src/types/string_utf8.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/string.h"
#include "gitmind/error.h"
#include "gitmind/utf8/validate.h"
#include <string.h>

/* Validate UTF-8 */
gm_result_void gm_string_validate_utf8(const gm_string_t* str) {
    if (!str) {
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "NULL string"));
    }
    
    /* Use DFA-based UTF-8 validator */
    gm_utf8_error_t utf8_err = gm_utf8_validate(str->data, str->length);
    
    if (utf8_err != GM_UTF8_OK) {
        const char* err_msg;
        switch (utf8_err) {
            case GM_UTF8_ERR_OVERLONG:
                err_msg = "Overlong UTF-8 encoding detected";
                break;
            case GM_UTF8_ERR_INVALID_START:
                err_msg = "Invalid UTF-8 start byte";
                break;
            case GM_UTF8_ERR_TRUNCATED:
                err_msg = "Truncated UTF-8 sequence";
                break;
            case GM_UTF8_ERR_SURROGATE:
                err_msg = "UTF-16 surrogate in UTF-8";
                break;
            case GM_UTF8_ERR_OUT_OF_RANGE:
                err_msg = "Codepoint out of Unicode range";
                break;
            default:
                err_msg = "Invalid UTF-8 encoding";
                break;
        }
        return gm_err_void(GM_ERROR(GM_ERR_INVALID_UTF8, err_msg));
    }
    
    return gm_ok_void();
}

# /Users/james/git/git-mind/core/src/utf8/validate.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

/*
 * DFA-based UTF-8 decoder/validator
 * 
 * Based on Björn Höhrmann's DFA decoder (http://bjoern.hoehrmann.de/utf-8/decoder/dfa/)
 * Original implementation is in the public domain.
 * 
 * This validator rejects:
 * - Overlong encodings
 * - UTF-16 surrogates (U+D800-U+DFFF)
 * - Codepoints > U+10FFFF
 * - Invalid byte sequences
 */

#include "gitmind/utf8/validate.h"

/* DFA states */
#define UTF8_ACCEPT 0
#define UTF8_REJECT 12

/* Force inline for performance */
#ifdef _MSC_VER
    #define GM_ALWAYS_INLINE __forceinline
#else
    #define GM_ALWAYS_INLINE __attribute__((always_inline)) inline
#endif

/* 
 * UTF-8 DFA lookup table
 * 
 * First 256 entries: maps bytes to character classes
 * Remaining entries: state transitions
 */
static const uint8_t utf8d[] = {
    /* Byte classification (0-255) */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 00-1F: ASCII control */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 20-3F: ASCII printable */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 40-5F: ASCII printable */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* 60-7F: ASCII printable */
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,  /* 80-9F: Continuation bytes */
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,  /* A0-BF: Continuation bytes */
    8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  /* C0-DF: 2-byte sequences */
    10,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3, 11,6,6,6,5,8,8,8,8,8,8,8,8,8,8,8,  /* E0-FF: 3-4 byte sequences */

    /* State transition table */
    0,12,24,36,60,96,84,12,12,12,48,72, 12,12,12,12,12,12,12,12,12,12,12,12,
    12, 0,12,12,12,12,12, 0,12, 0,12,12, 12,24,12,12,12,12,12,24,12,24,12,12,
    12,12,12,12,12,12,12,24,12,12,12,12, 12,24,12,12,12,12,12,12,12,24,12,12,
    12,12,12,12,12,12,12,36,12,36,12,12, 12,36,12,12,12,12,12,36,12,36,12,12,
    12,36,12,12,12,12,12,12,12,12,12,12,
};

/**
 * @brief Decode one UTF-8 byte
 * 
 * Updates state and codepoint based on input byte.
 * 
 * @param state Current state (modified)
 * @param codep Current codepoint (modified)
 * @param byte Input byte
 * @return New state (UTF8_ACCEPT, UTF8_REJECT, or intermediate)
 */
static GM_ALWAYS_INLINE uint32_t 
decode(uint32_t* state, uint32_t* codep, uint8_t byte) {
    uint32_t type = utf8d[byte];
    
    *codep = (*state != UTF8_ACCEPT) ?
        (byte & 0x3fu) | (*codep << 6) :
        (0xff >> type) & (byte);
        
    *state = utf8d[256 + *state + type];
    return *state;
}

/**
 * @brief Map DFA state to error code
 */
static gm_utf8_error_t state_to_error(uint32_t state, uint32_t codep) {
    if (state == UTF8_ACCEPT) {
        return GM_UTF8_OK;
    }
    
    /* Check for specific error conditions */
    if (state == UTF8_REJECT) {
        /* Check for surrogate */
        if (codep >= 0xD800 && codep <= 0xDFFF) {
            return GM_UTF8_ERR_SURROGATE;
        }
        /* Check for out of range */
        if (codep > 0x10FFFF) {
            return GM_UTF8_ERR_OUT_OF_RANGE;
        }
        /* Default to invalid start */
        return GM_UTF8_ERR_INVALID_START;
    }
    
    /* State != ACCEPT and != REJECT means truncated */
    return GM_UTF8_ERR_TRUNCATED;
}

gm_utf8_error_t gm_utf8_validate(const char* buf, size_t len) {
    uint32_t state = UTF8_ACCEPT;
    uint32_t codep = 0;
    
    for (size_t i = 0; i < len; i++) {
        uint32_t prev_state = state;
        decode(&state, &codep, (uint8_t)buf[i]);
        
        if (state == UTF8_REJECT) {
            /* Fast fail on first error */
            return state_to_error(state, codep);
        }
        
        /* Check for completed codepoint */
        if (prev_state != UTF8_ACCEPT && state == UTF8_ACCEPT) {
            /* We just completed a codepoint, check if it's valid */
            if (codep >= 0xD800 && codep <= 0xDFFF) {
                return GM_UTF8_ERR_SURROGATE;
            }
            if (codep > 0x10FFFF) {
                return GM_UTF8_ERR_OUT_OF_RANGE;
            }
        }
    }
    
    return state_to_error(state, codep);
}

void gm_utf8_state_init(gm_utf8_state_t* s) {
    s->state = UTF8_ACCEPT;
    s->codep = 0;
}

gm_utf8_error_t gm_utf8_validate_chunk(gm_utf8_state_t* s,
                                       const char* buf,
                                       size_t len) {
    for (size_t i = 0; i < len; i++) {
        uint32_t prev_state = s->state;
        decode(&s->state, &s->codep, (uint8_t)buf[i]);
        
        if (s->state == UTF8_REJECT) {
            /* Fast fail on first error */
            return state_to_error(s->state, s->codep);
        }
        
        /* Check for completed codepoint */
        if (prev_state != UTF8_ACCEPT && s->state == UTF8_ACCEPT) {
            /* We just completed a codepoint, check if it's valid */
            if (s->codep >= 0xD800 && s->codep <= 0xDFFF) {
                return GM_UTF8_ERR_SURROGATE;
            }
            if (s->codep > 0x10FFFF) {
                return GM_UTF8_ERR_OUT_OF_RANGE;
            }
        }
    }
    
    /* Chunk is valid so far */
    return GM_UTF8_OK;
}

bool gm_utf8_state_is_complete(const gm_utf8_state_t* s) {
    return s->state == UTF8_ACCEPT;
}

# /Users/james/git/git-mind/core/tests/unit/test_crypto_backend.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/crypto/backend.h"
#include "gitmind/crypto/sha256.h"
#include "gitmind/crypto/random.h"
#include "gitmind/error.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

/* Test backend switching */
static void test_backend_switch(void) {
    /* Initialize crypto system */
    gm_result_void init_result = gm_crypto_init();
    assert(GM_IS_OK(init_result));
    
    /* Default should be libsodium */
    gm_crypto_backend_t* backend = gm_crypto_get_backend();
    assert(backend != NULL);
    assert(strcmp(backend->name, "libsodium") == 0);
    
    /* Test with libsodium backend */
    uint8_t hash1[GM_SHA256_DIGEST_SIZE];
    gm_result_void sha_result = gm_sha256("test", 4, hash1);
    assert(GM_IS_OK(sha_result));
    
    /* Switch to test backend */
    gm_result_backend result = gm_crypto_set_backend(gm_crypto_backend_test());
    assert(GM_IS_OK(result));
    
    backend = gm_crypto_get_backend();
    assert(strcmp(backend->name, "test") == 0);
    
    /* Test with test backend (should be deterministic) */
    uint8_t hash2[GM_SHA256_DIGEST_SIZE];
    sha_result = gm_sha256("test", 4, hash2);
    assert(GM_IS_OK(sha_result));
    
    /* Test backend should produce predictable output */
    assert(hash2[0] == 4);  /* Length & 0xFF */
    assert(hash2[1] == 0);  /* (Length >> 8) & 0xFF */
    assert(hash2[2] == 0);  /* (Length >> 16) & 0xFF */
    assert(hash2[3] == 0);  /* (Length >> 24) & 0xFF */
    assert(memcmp(hash2 + 4, "test", 4) == 0);
    
    /* Hashes should be different */
    assert(memcmp(hash1, hash2, GM_SHA256_DIGEST_SIZE) != 0);
    
    /* Switch back to libsodium */
    result = gm_crypto_set_backend(gm_crypto_backend_libsodium());
    assert(GM_IS_OK(result));
    
    uint8_t hash3[GM_SHA256_DIGEST_SIZE];
    sha_result = gm_sha256("test", 4, hash3);
    assert(GM_IS_OK(sha_result));
    
    /* Should match first hash */
    assert(memcmp(hash1, hash3, GM_SHA256_DIGEST_SIZE) == 0);
    
    printf("✓ test_backend_switch\n");
}

/* Test deterministic random in test backend */
static void test_deterministic_random(void) {
    /* Switch to test backend */
    gm_result_backend result = gm_crypto_set_backend(gm_crypto_backend_test());
    assert(GM_IS_OK(result));
    
    /* Random should be deterministic */
    gm_result_u32 r1_result = gm_random_u32();
    assert(GM_IS_OK(r1_result));
    uint32_t r1 = GM_UNWRAP(r1_result);
    
    gm_result_u32 r2_result = gm_random_u32();
    assert(GM_IS_OK(r2_result));
    uint32_t r2 = GM_UNWRAP(r2_result);
    
    gm_result_u32 r3_result = gm_random_u32();
    assert(GM_IS_OK(r3_result));
    uint32_t r3 = GM_UNWRAP(r3_result);
    
    assert(r1 == 0);
    assert(r2 == 1);
    assert(r3 == 2);
    
    /* Test random bytes */
    uint8_t buf[10];
    gm_result_void rand_result = gm_random_bytes(buf, sizeof(buf));
    assert(GM_IS_OK(rand_result));
    
    for (int i = 0; i < 10; i++) {
        assert(buf[i] == (uint8_t)(3 + i));  /* Continues from where u32 left off */
    }
    
    /* Switch to new test backend instance (resets counter) */
    result = gm_crypto_set_backend(gm_crypto_backend_test());
    assert(GM_IS_OK(result));
    
    /* Should restart from 0 */
    r1_result = gm_random_u32();
    assert(GM_IS_OK(r1_result));
    r1 = GM_UNWRAP(r1_result);
    assert(r1 == 0);
    
    printf("✓ test_deterministic_random\n");
}

/* Test streaming hash with backend */
static void test_streaming_hash(void) {
    /* Test with both backends */
    gm_crypto_backend_t* backends[] = {
        gm_crypto_backend_libsodium(),
        gm_crypto_backend_test()
    };
    
    for (int i = 0; i < 2; i++) {
        gm_result_backend result = gm_crypto_set_backend(backends[i]);
        assert(GM_IS_OK(result));
        
        /* Streaming hash */
        gm_sha256_ctx_t ctx;
        gm_result_void hash_result = gm_sha256_init(&ctx);
        assert(GM_IS_OK(hash_result));
        
        hash_result = gm_sha256_update(&ctx, "hello", 5);
        assert(GM_IS_OK(hash_result));
        
        hash_result = gm_sha256_update(&ctx, " ", 1);
        assert(GM_IS_OK(hash_result));
        
        hash_result = gm_sha256_update(&ctx, "world", 5);
        assert(GM_IS_OK(hash_result));
        
        uint8_t hash1[GM_SHA256_DIGEST_SIZE];
        hash_result = gm_sha256_final(&ctx, hash1);
        assert(GM_IS_OK(hash_result));
        
        /* One-shot hash */
        uint8_t hash2[GM_SHA256_DIGEST_SIZE];
        hash_result = gm_sha256("hello world", 11, hash2);
        assert(GM_IS_OK(hash_result));
        
        if (i == 0) {
            /* Libsodium backend should produce matching hashes */
            assert(memcmp(hash1, hash2, GM_SHA256_DIGEST_SIZE) == 0);
        } else {
            /* Test backend uses different algorithm for streaming */
            /* Just verify it produces something */
            assert(hash1[0] != 0 || hash1[1] != 0);
        }
    }
    
    printf("✓ test_streaming_hash\n");
}

/* Test invalid backend */
static void test_invalid_backend(void) {
    /* NULL backend */
    gm_result_backend result = gm_crypto_set_backend(NULL);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    /* Backend with missing functions */
    gm_crypto_backend_t incomplete = {
        .name = "incomplete",
        .sha256 = NULL,  /* Missing function */
        .sha256_init = NULL,
        .sha256_update = NULL,
        .sha256_final = NULL,
        .random_bytes = NULL,
        .random_u32 = NULL,
        .random_u64 = NULL,
        .context = NULL
    };
    
    result = gm_crypto_set_backend(&incomplete);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    printf("✓ test_invalid_backend\n");
}

int main(void) {
    printf("Running crypto backend tests...\n\n");
    
    test_backend_switch();
    test_deterministic_random();
    test_streaming_hash();
    test_invalid_backend();
    
    /* Cleanup */
    gm_result_void cleanup_result = gm_crypto_cleanup();
    assert(GM_IS_OK(cleanup_result));
    
    printf("\n✅ All crypto backend tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_error.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/error.h"
#include "gitmind/result.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Helper to get error message for tests */
static const char* test_get_error_message(const gm_error_t* err) {
    return err->heap_alloc ? err->msg.heap : err->msg.small;
}

/* Test basic error creation */
static void test_error_new(void) {
    gm_error_t* err = gm_error_new(GM_ERR_INVALID_ARGUMENT, "Test error: %d", 42);
    
    assert(err != NULL);
    assert(err->code == GM_ERR_INVALID_ARGUMENT);
    assert(strcmp(test_get_error_message(err), "Test error: 42") == 0);
    assert(err->cause == NULL);
    
    gm_error_free(err);
    printf("✓ test_error_new\n");
}

/* Test error with location */
static void test_error_with_location(void) {
    gm_error_t* err = GM_ERROR(GM_ERR_NOT_FOUND, "File not found: %s", "test.txt");
    
    assert(err != NULL);
    assert(err->code == GM_ERR_NOT_FOUND);
    assert(err->file != NULL);
    assert(err->line > 0);
    assert(err->func != NULL);
    assert(strstr(err->func, "test_error_with_location") != NULL);
    
    gm_error_free(err);
    printf("✓ test_error_with_location\n");
}

/* Test error chaining */
static void test_error_chain(void) {
    gm_error_t* cause = gm_error_new(GM_ERR_FILE_NOT_FOUND, "config.toml not found");
    gm_error_t* err = gm_error_wrap(cause, GM_ERR_INVALID_STATE, "Failed to load config");
    
    assert(err != NULL);
    assert(err->code == GM_ERR_INVALID_STATE);
    assert(err->cause == cause);
    assert(err->cause->code == GM_ERR_FILE_NOT_FOUND);
    
    gm_error_free(err); /* Should free entire chain */
    printf("✓ test_error_chain\n");
}

/* Test result types */
static void test_result_success(void) {
    gm_result_int result = gm_ok_int(42);
    
    assert(GM_IS_OK(result));
    assert(!GM_IS_ERR(result));
    assert(GM_UNWRAP(result) == 42);
    
    printf("✓ test_result_success\n");
}

/* Test result error */
static void test_result_error(void) {
    gm_error_t* err = gm_error_new(GM_ERR_INVALID_ARGUMENT, "Bad input");
    gm_result_int result = gm_err_int(err);
    
    assert(!GM_IS_OK(result));
    assert(GM_IS_ERR(result));
    assert(GM_UNWRAP_ERR(result) == err);
    assert(GM_UNWRAP_ERR(result)->code == GM_ERR_INVALID_ARGUMENT);
    
    gm_error_free(GM_UNWRAP_ERR(result));
    printf("✓ test_result_error\n");
}

/* Test function that uses results */
static gm_result_int divide(int a, int b) {
    if (b == 0) {
        return gm_err_int(GM_ERROR(GM_ERR_INVALID_ARGUMENT, "Division by zero"));
    }
    return gm_ok_int(a / b);
}

/* Test GM_TRY macro */
static gm_result_int calculate(int x, int y) {
    gm_result_int div_result = divide(x, y);
    GM_TRY(div_result);
    
    int quotient = GM_UNWRAP(div_result);
    return gm_ok_int(quotient * 2);
}

static void test_try_macro(void) {
    /* Success case */
    gm_result_int result = calculate(10, 2);
    assert(GM_IS_OK(result));
    assert(GM_UNWRAP(result) == 10); /* (10/2) * 2 = 10 */
    
    /* Error case */
    result = calculate(10, 0);
    assert(GM_IS_ERR(result));
    assert(GM_UNWRAP_ERR(result)->code == GM_ERR_INVALID_ARGUMENT);
    
    gm_error_free(GM_UNWRAP_ERR(result));
    printf("✓ test_try_macro\n");
}

/* Test error formatting */
static void test_error_format(void) {
    gm_error_t* cause = gm_error_new(GM_ERR_FILE_NOT_FOUND, "config.toml not found");
    gm_error_t* err = gm_error_wrap(cause, GM_ERR_INVALID_STATE, "Failed to initialize");
    
    char* formatted = gm_error_format(err);
    assert(formatted != NULL);
    assert(strstr(formatted, "Failed to initialize") != NULL);
    assert(strstr(formatted, "caused by:") != NULL);
    assert(strstr(formatted, "config.toml not found") != NULL);
    
    free(formatted);
    gm_error_free(err);
    printf("✓ test_error_format\n");
}

/* Test SSO (Small String Optimization) */
static void test_error_sso(void) {
    /* Small message - should use inline storage */
    gm_error_t* err1 = gm_error_new(GM_ERR_INVALID_ARGUMENT, "Small msg");
    assert(err1 != NULL);
    assert(!err1->heap_alloc);  /* Should use small buffer */
    assert(err1->len == strlen("Small msg"));
    assert(strcmp(test_get_error_message(err1), "Small msg") == 0);
    
    /* Message exactly at threshold (47 chars + null) */
    const char* threshold_msg = "This message is exactly 47 characters long!!!";
    assert(strlen(threshold_msg) == 45);  /* Fits in 48-byte buffer */
    gm_error_t* err2 = gm_error_new(GM_ERR_INVALID_ARGUMENT, "%s", threshold_msg);
    assert(err2 != NULL);
    assert(!err2->heap_alloc);  /* Should still use small buffer */
    assert(strcmp(test_get_error_message(err2), threshold_msg) == 0);
    
    /* Large message - should use heap allocation */
    const char* large_msg = "This is a very long error message that exceeds the small string optimization "
                           "threshold and should be allocated on the heap instead of using inline storage";
    assert(strlen(large_msg) > GM_ERROR_SMALL_SIZE);
    gm_error_t* err3 = gm_error_new(GM_ERR_INVALID_ARGUMENT, "%s", large_msg);
    assert(err3 != NULL);
    assert(err3->heap_alloc);  /* Should use heap */
    assert(err3->len == strlen(large_msg));
    assert(strcmp(test_get_error_message(err3), large_msg) == 0);
    
    gm_error_free(err1);
    gm_error_free(err2);
    gm_error_free(err3);
    printf("✓ test_error_sso\n");
}

int main(void) {
    printf("Running error handling tests...\n\n");
    
    test_error_new();
    test_error_with_location();
    test_error_chain();
    test_result_success();
    test_result_error();
    test_try_macro();
    test_error_format();
    test_error_sso();
    
    printf("\n✅ All tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_id.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/id.h"
#include "gitmind/error.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Test ID creation from string */
static void test_id_from_string(void) {
    gm_result_id result1 = gm_id_from_string("hello");
    assert(GM_IS_OK(result1));
    gm_id_t id1 = GM_UNWRAP(result1);
    
    gm_result_id result2 = gm_id_from_string("hello");
    assert(GM_IS_OK(result2));
    gm_id_t id2 = GM_UNWRAP(result2);
    
    gm_result_id result3 = gm_id_from_string("world");
    assert(GM_IS_OK(result3));
    gm_id_t id3 = GM_UNWRAP(result3);
    
    /* Same input should produce same ID */
    assert(gm_id_equal(id1, id2));
    
    /* Different input should produce different ID */
    assert(!gm_id_equal(id1, id3));
    
    /* Test error case - NULL input */
    gm_result_id err_result = gm_id_from_string(NULL);
    assert(GM_IS_ERR(err_result));
    gm_error_free(GM_UNWRAP_ERR(err_result));
    
    printf("✓ test_id_from_string\n");
}

/* Test ID to/from hex */
static void test_id_hex_conversion(void) {
    gm_result_id id_result = gm_id_from_string("test");
    assert(GM_IS_OK(id_result));
    gm_id_t id = GM_UNWRAP(id_result);
    
    char hex[GM_ID_HEX_SIZE];
    gm_id_to_hex(id, hex);
    assert(strlen(hex) == GM_ID_HEX_CHARS); /* SHA-256 hex representation */
    
    /* Parse back */
    gm_result_id result = gm_id_from_hex(hex);
    assert(GM_IS_OK(result));
    
    gm_id_t parsed = GM_UNWRAP(result);
    assert(gm_id_equal(id, parsed));
    
    printf("✓ test_id_hex_conversion\n");
}

/* Test invalid hex parsing */
static void test_id_hex_invalid(void) {
    /* Too short */
    gm_result_id result = gm_id_from_hex("abc");
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    /* Invalid characters */
    result = gm_id_from_hex("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz");
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    /* NULL */
    result = gm_id_from_hex(NULL);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    printf("✓ test_id_hex_invalid\n");
}

/* Test strongly typed IDs */
static void test_typed_ids(void) {
    gm_result_id node1_result = gm_id_from_string("node1");
    assert(GM_IS_OK(node1_result));
    gm_node_id_t node1 = { .base = GM_UNWRAP(node1_result) };
    
    gm_result_id node2_result = gm_id_from_string("node2");
    assert(GM_IS_OK(node2_result));
    gm_node_id_t node2 = { .base = GM_UNWRAP(node2_result) };
    
    gm_result_id edge1_result = gm_id_from_string("edge1");
    assert(GM_IS_OK(edge1_result));
    gm_edge_id_t edge1 = { .base = GM_UNWRAP(edge1_result) };
    
    gm_result_id edge2_result = gm_id_from_string("edge2");
    assert(GM_IS_OK(edge2_result));
    gm_edge_id_t edge2 = { .base = GM_UNWRAP(edge2_result) };
    
    /* Can compare same types */
    assert(!gm_node_id_equal(node1, node2));
    assert(!gm_edge_id_equal(edge1, edge2));
    
    /* Cannot compare different types (won't compile) */
    /* assert(gm_node_id_equal(node1, edge1)); // COMPILE ERROR! */
    
    /* Can convert to hex */
    char hex[GM_ID_HEX_SIZE];
    gm_node_id_to_hex(node1, hex);
    assert(strlen(hex) == GM_ID_HEX_CHARS);
    
    /* Edge IDs also convert to hex */
    gm_edge_id_to_hex(edge1, hex);
    assert(strlen(hex) == GM_ID_HEX_CHARS);
    
    printf("✓ test_typed_ids\n");
}

/* Test ID generation */
static void test_id_generate(void) {
    gm_result_id result1 = gm_id_generate();
    assert(GM_IS_OK(result1));
    gm_id_t id1 = GM_UNWRAP(result1);
    
    gm_result_id result2 = gm_id_generate();
    assert(GM_IS_OK(result2));
    gm_id_t id2 = GM_UNWRAP(result2);
    
    /* Generated IDs should be different */
    assert(!gm_id_equal(id1, id2));
    
    printf("✓ test_id_generate\n");
}

/* Test session ID */
static void test_session_id(void) {
    gm_result_session_id result1 = gm_session_id_new();
    assert(GM_IS_OK(result1));
    gm_session_id_t sid1 = GM_UNWRAP(result1);
    
    gm_result_session_id result2 = gm_session_id_new();
    assert(GM_IS_OK(result2));
    gm_session_id_t sid2 = GM_UNWRAP(result2);
    
    /* Session IDs should be unique */
    assert(!gm_session_id_equal(sid1, sid2));
    
    printf("✓ test_session_id\n");
}

/* Test ID creation from data */
static void test_id_from_data(void) {
    const uint8_t data1[] = {0x01, 0x02, 0x03, 0x04};
    const uint8_t data2[] = {0x01, 0x02, 0x03, 0x04};
    const uint8_t data3[] = {0x04, 0x03, 0x02, 0x01};
    
    gm_result_id result1 = gm_id_from_data(data1, sizeof(data1));
    assert(GM_IS_OK(result1));
    gm_id_t id1 = GM_UNWRAP(result1);
    
    gm_result_id result2 = gm_id_from_data(data2, sizeof(data2));
    assert(GM_IS_OK(result2));
    gm_id_t id2 = GM_UNWRAP(result2);
    
    gm_result_id result3 = gm_id_from_data(data3, sizeof(data3));
    assert(GM_IS_OK(result3));
    gm_id_t id3 = GM_UNWRAP(result3);
    
    /* Same data should produce same ID */
    assert(gm_id_equal(id1, id2));
    
    /* Different data should produce different ID */
    assert(!gm_id_equal(id1, id3));
    
    /* Test error case - NULL data */
    gm_result_id err_result = gm_id_from_data(NULL, 10);
    assert(GM_IS_ERR(err_result));
    gm_error_free(GM_UNWRAP_ERR(err_result));
    
    /* Test zero length - should succeed (SHA256 of empty data is valid) */
    gm_result_id zero_result = gm_id_from_data(data1, 0);
    assert(GM_IS_OK(zero_result));
    /* SHA256 of empty string should be e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 */
    
    printf("✓ test_id_from_data\n");
}

/* Test improved hash function */
static void test_id_hash(void) {
    /* Create IDs that differ only in the last bytes */
    gm_id_t id1, id2;
    memset(id1.bytes, 0xAA, GM_ID_SIZE);
    memset(id2.bytes, 0xAA, GM_ID_SIZE);
    id2.bytes[GM_ID_SIZE - 1] = 0xBB;  /* Only last byte different */
    
    uint32_t hash1 = gm_id_hash(id1);
    uint32_t hash2 = gm_id_hash(id2);
    
    /* Hashes should be different (SipHash uses all bytes) */
    assert(hash1 != hash2);
    
    /* Create IDs that differ only in the first bytes */
    gm_id_t id3, id4;
    memset(id3.bytes, 0xCC, GM_ID_SIZE);
    memset(id4.bytes, 0xCC, GM_ID_SIZE);
    id4.bytes[0] = 0xDD;  /* Only first byte different */
    
    uint32_t hash3 = gm_id_hash(id3);
    uint32_t hash4 = gm_id_hash(id4);
    
    /* Hashes should be different */
    assert(hash3 != hash4);
    
    /* Test that same ID produces same hash */
    assert(gm_id_hash(id1) == hash1);
    assert(gm_id_hash(id2) == hash2);
    
    printf("✓ test_id_hash\n");
}

int main(void) {
    printf("Running ID type tests...\n\n");
    
    test_id_from_string();
    test_id_from_data();
    test_id_hex_conversion();
    test_id_hex_invalid();
    test_typed_ids();
    test_id_generate();
    test_session_id();
    test_id_hash();
    
    printf("\n✅ All ID tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_path.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/path.h"
#include "gitmind/error.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

/* Test path creation */
static void test_path_new(void) {
    /* Basic path */
    gm_result_path result = gm_path_new("/usr/local/bin");
    assert(GM_IS_OK(result));
    
    gm_path_t path = GM_UNWRAP(result);
    assert(strcmp(gm_path_str(&path), "/usr/local/bin") == 0);
    assert(path.separator == '/');
    assert(path.is_absolute == true);
    assert(path.is_validated == true);
    
    gm_path_free(&path);
    
    /* Relative path */
    result = gm_path_new("src/main.c");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    assert(strcmp(gm_path_str(&path), "src/main.c") == 0);
    assert(path.is_absolute == false);
    
    gm_path_free(&path);
    
    /* Empty path */
    result = gm_path_new("");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    assert(gm_path_is_empty(&path));
    
    gm_path_free(&path);
    
    /* NULL path (treated as empty) */
    result = gm_path_new(NULL);
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    assert(gm_path_is_empty(&path));
    
    gm_path_free(&path);
    
    printf("✓ test_path_new\n");
}

/* Test path joining */
static void test_path_join(void) {
    gm_result_path base_result = gm_path_new("/home/user");
    gm_result_path rel_result = gm_path_new("documents/file.txt");
    
    assert(GM_IS_OK(base_result) && GM_IS_OK(rel_result));
    
    gm_path_t base = GM_UNWRAP(base_result);
    gm_path_t rel = GM_UNWRAP(rel_result);
    
    /* Join paths */
    gm_result_path joined_result = gm_path_join(&base, &rel);
    assert(GM_IS_OK(joined_result));
    
    gm_path_t joined = GM_UNWRAP(joined_result);
    assert(strcmp(gm_path_str(&joined), "/home/user/documents/file.txt") == 0);
    
    gm_path_free(&base);
    gm_path_free(&rel);
    gm_path_free(&joined);
    
    /* Join with trailing separator */
    base_result = gm_path_new("/home/user/");
    rel_result = gm_path_new("documents");
    assert(GM_IS_OK(base_result) && GM_IS_OK(rel_result));
    
    base = GM_UNWRAP(base_result);
    rel = GM_UNWRAP(rel_result);
    
    joined_result = gm_path_join(&base, &rel);
    assert(GM_IS_OK(joined_result));
    
    joined = GM_UNWRAP(joined_result);
    assert(strcmp(gm_path_str(&joined), "/home/user/documents") == 0);
    
    gm_path_free(&base);
    gm_path_free(&rel);
    gm_path_free(&joined);
    
    /* Join with absolute relative path (returns relative) */
    base_result = gm_path_new("/home/user");
    rel_result = gm_path_new("/etc/config");
    assert(GM_IS_OK(base_result) && GM_IS_OK(rel_result));
    
    base = GM_UNWRAP(base_result);
    rel = GM_UNWRAP(rel_result);
    
    joined_result = gm_path_join(&base, &rel);
    assert(GM_IS_OK(joined_result));
    
    joined = GM_UNWRAP(joined_result);
    assert(strcmp(gm_path_str(&joined), "/etc/config") == 0);
    
    gm_path_free(&base);
    gm_path_free(&rel);
    gm_path_free(&joined);
    
    printf("✓ test_path_join\n");
}

/* Test dirname extraction */
static void test_path_dirname(void) {
    /* Normal path */
    gm_result_path result = gm_path_new("/home/user/file.txt");
    assert(GM_IS_OK(result));
    
    gm_path_t path = GM_UNWRAP(result);
    
    gm_result_path dir_result = gm_path_dirname(&path);
    assert(GM_IS_OK(dir_result));
    
    gm_path_t dir = GM_UNWRAP(dir_result);
    assert(strcmp(gm_path_str(&dir), "/home/user") == 0);
    
    gm_path_free(&path);
    gm_path_free(&dir);
    
    /* Path without directory */
    result = gm_path_new("file.txt");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    dir_result = gm_path_dirname(&path);
    assert(GM_IS_OK(dir_result));
    
    dir = GM_UNWRAP(dir_result);
    assert(strcmp(gm_path_str(&dir), ".") == 0);
    
    gm_path_free(&path);
    gm_path_free(&dir);
    
    /* Root path */
    result = gm_path_new("/");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    dir_result = gm_path_dirname(&path);
    assert(GM_IS_OK(dir_result));
    
    dir = GM_UNWRAP(dir_result);
    assert(strcmp(gm_path_str(&dir), "/") == 0);
    
    gm_path_free(&path);
    gm_path_free(&dir);
    
    printf("✓ test_path_dirname\n");
}

/* Test basename extraction */
static void test_path_basename(void) {
    /* Normal path */
    gm_result_path result = gm_path_new("/home/user/file.txt");
    assert(GM_IS_OK(result));
    
    gm_path_t path = GM_UNWRAP(result);
    
    gm_result_path base_result = gm_path_basename(&path);
    assert(GM_IS_OK(base_result));
    
    gm_path_t base = GM_UNWRAP(base_result);
    assert(strcmp(gm_path_str(&base), "file.txt") == 0);
    
    gm_path_free(&path);
    gm_path_free(&base);
    
    /* Path without directory */
    result = gm_path_new("file.txt");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    base_result = gm_path_basename(&path);
    assert(GM_IS_OK(base_result));
    
    base = GM_UNWRAP(base_result);
    assert(strcmp(gm_path_str(&base), "file.txt") == 0);
    
    gm_path_free(&path);
    gm_path_free(&base);
    
    /* Directory path */
    result = gm_path_new("/home/user/");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    base_result = gm_path_basename(&path);
    assert(GM_IS_OK(base_result));
    
    base = GM_UNWRAP(base_result);
    assert(strcmp(gm_path_str(&base), "") == 0);
    
    gm_path_free(&path);
    gm_path_free(&base);
    
    printf("✓ test_path_basename\n");
}

/* Test path safety checks */
static void test_path_safety(void) {
    /* Safe paths */
    gm_result_path result = gm_path_new("/home/user/docs");
    assert(GM_IS_OK(result));
    gm_path_t path = GM_UNWRAP(result);
    assert(gm_path_is_safe(&path));
    gm_path_free(&path);
    
    result = gm_path_new("src/main.c");
    assert(GM_IS_OK(result));
    path = GM_UNWRAP(result);
    assert(gm_path_is_safe(&path));
    gm_path_free(&path);
    
    /* Unsafe paths with .. */
    result = gm_path_new("../etc/passwd");
    assert(GM_IS_OK(result));
    path = GM_UNWRAP(result);
    assert(!gm_path_is_safe(&path));
    gm_path_free(&path);
    
    result = gm_path_new("/home/user/../../../etc");
    assert(GM_IS_OK(result));
    path = GM_UNWRAP(result);
    assert(!gm_path_is_safe(&path));
    gm_path_free(&path);
    
    printf("✓ test_path_safety\n");
}

/* Test path extensions */
static void test_path_extension(void) {
    gm_result_path result = gm_path_new("document.pdf");
    assert(GM_IS_OK(result));
    
    gm_path_t path = GM_UNWRAP(result);
    assert(gm_path_has_extension(&path, ".pdf"));
    assert(!gm_path_has_extension(&path, ".txt"));
    assert(!gm_path_has_extension(&path, ".pd"));
    
    gm_path_free(&path);
    
    /* Path without extension */
    result = gm_path_new("README");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    assert(!gm_path_has_extension(&path, ".txt"));
    
    gm_path_free(&path);
    
    /* Hidden file */
    result = gm_path_new(".gitignore");
    assert(GM_IS_OK(result));
    
    path = GM_UNWRAP(result);
    assert(!gm_path_has_extension(&path, ".gitignore"));
    
    gm_path_free(&path);
    
    printf("✓ test_path_extension\n");
}

/* Test path comparison */
static void test_path_compare(void) {
    gm_result_path r1 = gm_path_new("/home/user");
    gm_result_path r2 = gm_path_new("/home/user");
    gm_result_path r3 = gm_path_new("/home/other");
    
    assert(GM_IS_OK(r1) && GM_IS_OK(r2) && GM_IS_OK(r3));
    
    gm_path_t p1 = GM_UNWRAP(r1);
    gm_path_t p2 = GM_UNWRAP(r2);
    gm_path_t p3 = GM_UNWRAP(r3);
    
    assert(gm_path_equals(&p1, &p2));
    assert(!gm_path_equals(&p1, &p3));
    
    /* Prefix check */
    gm_result_path r4 = gm_path_new("/home/user/documents");
    assert(GM_IS_OK(r4));
    gm_path_t p4 = GM_UNWRAP(r4);
    
    assert(gm_path_starts_with(&p4, &p1));
    assert(!gm_path_starts_with(&p1, &p4));
    
    /* Child check */
    assert(gm_path_is_child_of(&p4, &p1));
    assert(!gm_path_is_child_of(&p1, &p4));
    assert(!gm_path_is_child_of(&p1, &p3));
    
    gm_path_free(&p1);
    gm_path_free(&p2);
    gm_path_free(&p3);
    gm_path_free(&p4);
    
    printf("✓ test_path_compare\n");
}

/* Test canonicalization */
static void test_path_canonicalize(void) {
    gm_result_path result = gm_path_new("/home/user/./documents");
    assert(GM_IS_OK(result));
    
    gm_path_t path = GM_UNWRAP(result);
    assert(path.state == GM_PATH_STATE_RAW);
    
    gm_result_path canon_result = gm_path_canonicalize(&path);
    assert(GM_IS_OK(canon_result));
    
    gm_path_t canon = GM_UNWRAP(canon_result);
    assert(canon.state == GM_PATH_STATE_CANONICAL);
    
    gm_path_free(&path);
    gm_path_free(&canon);
    
    printf("✓ test_path_canonicalize\n");
}

int main(void) {
    printf("Running path type tests...\n\n");
    
    test_path_new();
    test_path_join();
    test_path_dirname();
    test_path_basename();
    test_path_safety();
    test_path_extension();
    test_path_compare();
    test_path_canonicalize();
    
    printf("\n✅ All path tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_random.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/crypto/random.h"
#include "gitmind/error.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

#define RANDOM_TEST_SIZE 32
#define RANDOM_TEST_ITERATIONS 100

/* Test random bytes generation */
static void test_random_bytes(void) {
    uint8_t buf1[RANDOM_TEST_SIZE];
    uint8_t buf2[RANDOM_TEST_SIZE];
    
    /* Generate two random buffers */
    gm_result_void result1 = gm_random_bytes(buf1, sizeof(buf1));
    assert(GM_IS_OK(result1));
    
    gm_result_void result2 = gm_random_bytes(buf2, sizeof(buf2));
    assert(GM_IS_OK(result2));
    
    /* They should be different (probability of collision is negligible) */
    assert(memcmp(buf1, buf2, sizeof(buf1)) != 0);
    
    /* Should not be all zeros */
    uint8_t zeros[RANDOM_TEST_SIZE] = {0};
    assert(memcmp(buf1, zeros, sizeof(buf1)) != 0);
    assert(memcmp(buf2, zeros, sizeof(buf2)) != 0);
    
    /* Test error case - NULL buffer */
    gm_result_void err_result = gm_random_bytes(NULL, 10);
    assert(GM_IS_ERR(err_result));
    gm_error_free(GM_UNWRAP_ERR(err_result));
    
    /* Test zero size - should succeed but do nothing */
    gm_result_void zero_result = gm_random_bytes(buf1, 0);
    assert(GM_IS_OK(zero_result));
    
    printf("✓ test_random_bytes\n");
}

/* Test random u32 generation */
static void test_random_u32(void) {
    uint32_t values[RANDOM_TEST_ITERATIONS];
    
    /* Generate multiple random values */
    for (int i = 0; i < RANDOM_TEST_ITERATIONS; i++) {
        gm_result_u32 result = gm_random_u32();
        assert(GM_IS_OK(result));
        values[i] = GM_UNWRAP(result);
    }
    
    /* Check for uniqueness (very likely with CSPRNG) */
    int unique_count = 0;
    for (int i = 0; i < RANDOM_TEST_ITERATIONS; i++) {
        int is_unique = 1;
        for (int j = 0; j < i; j++) {
            if (values[i] == values[j]) {
                is_unique = 0;
                break;
            }
        }
        if (is_unique) unique_count++;
    }
    
    /* Should have mostly unique values */
    assert(unique_count > RANDOM_TEST_ITERATIONS * 0.9);
    
    printf("✓ test_random_u32\n");
}

/* Test random u64 generation */
static void test_random_u64(void) {
    gm_result_u64 result1 = gm_random_u64();
    assert(GM_IS_OK(result1));
    uint64_t val1 = GM_UNWRAP(result1);
    
    gm_result_u64 result2 = gm_random_u64();
    assert(GM_IS_OK(result2));
    uint64_t val2 = GM_UNWRAP(result2);
    
    /* Should be different */
    assert(val1 != val2);
    
    /* Should not be zero (extremely unlikely) */
    assert(val1 != 0);
    assert(val2 != 0);
    
    printf("✓ test_random_u64\n");
}

/* Test entropy quality (basic check) */
static void test_entropy_quality(void) {
    /* Generate a larger buffer */
    uint8_t buf[1024];
    gm_result_void result = gm_random_bytes(buf, sizeof(buf));
    assert(GM_IS_OK(result));
    
    /* Count bit distribution */
    int zero_bits = 0;
    int one_bits = 0;
    
    for (size_t i = 0; i < sizeof(buf); i++) {
        for (int bit = 0; bit < 8; bit++) {
            if (buf[i] & (1 << bit)) {
                one_bits++;
            } else {
                zero_bits++;
            }
        }
    }
    
    /* Should be roughly 50/50 distribution */
    int total_bits = sizeof(buf) * 8;
    double zero_ratio = (double)zero_bits / total_bits;
    double one_ratio = (double)one_bits / total_bits;
    
    /* Allow 45-55% range */
    assert(zero_ratio > 0.45 && zero_ratio < 0.55);
    assert(one_ratio > 0.45 && one_ratio < 0.55);
    
    printf("✓ test_entropy_quality (0s: %.1f%%, 1s: %.1f%%)\n", 
           zero_ratio * 100, one_ratio * 100);
}

int main(void) {
    printf("Running CSPRNG tests...\n\n");
    
    test_random_bytes();
    test_random_u32();
    test_random_u64();
    test_entropy_quality();
    
    printf("\n✅ All CSPRNG tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_sha256.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/crypto/sha256.h"
#include "gitmind/error.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

/* Test vector structure */
typedef struct {
    const char* msg;
    const char* hex;
} test_vector_t;

/* Convert hex string to bytes */
static void hex_to_bytes(const char* hex, uint8_t* out, size_t out_len) {
    for (size_t i = 0; i < out_len; i++) {
        unsigned int byte;
        sscanf(hex + i * 2, "%2x", &byte);
        out[i] = (uint8_t)byte;
    }
}

/* Convert bytes to hex string */
static void bytes_to_hex(const uint8_t* bytes, size_t len, char* hex) {
    static const char hex_chars[] = "0123456789abcdef";
    for (size_t i = 0; i < len; i++) {
        hex[i * 2]     = hex_chars[bytes[i] >> 4];
        hex[i * 2 + 1] = hex_chars[bytes[i] & 0x0F];
    }
    hex[len * 2] = '\0';
}

/* Test SHA256 with official test vectors */
static void test_sha256_vectors(void) {
    /* NIST test vectors */
    static const test_vector_t vectors[] = {
        /* Empty string */
        { "", 
          "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" },
        /* "abc" */
        { "abc", 
          "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad" },
        /* "The quick brown fox jumps over the lazy dog" */
        { "The quick brown fox jumps over the lazy dog",
          "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592" },
        /* Long string */
        { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
          "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1" }
    };

    for (size_t i = 0; i < sizeof(vectors) / sizeof(vectors[0]); i++) {
        uint8_t out[GM_SHA256_DIGEST_SIZE];
        uint8_t expected[GM_SHA256_DIGEST_SIZE];
        char out_hex[GM_SHA256_DIGEST_SIZE * 2 + 1];
        
        /* Convert expected hex to bytes */
        hex_to_bytes(vectors[i].hex, expected, GM_SHA256_DIGEST_SIZE);
        
        /* Compute SHA256 */
        gm_result_void result = gm_sha256(vectors[i].msg, strlen(vectors[i].msg), out);
        assert(GM_IS_OK(result));
        
        /* Verify */
        if (memcmp(out, expected, GM_SHA256_DIGEST_SIZE) != 0) {
            bytes_to_hex(out, GM_SHA256_DIGEST_SIZE, out_hex);
            printf("❌ SHA256 test vector %zu failed\n", i);
            printf("  Input:    \"%s\"\n", vectors[i].msg);
            printf("  Expected: %s\n", vectors[i].hex);
            printf("  Got:      %s\n", out_hex);
            assert(0);
        }
    }
    
    printf("✓ test_sha256_vectors\n");
}

/* Test streaming SHA256 API */
static void test_sha256_streaming(void) {
    /* Test that streaming produces same result as one-shot */
    const char* test_data = "The quick brown fox jumps over the lazy dog";
    uint8_t one_shot[GM_SHA256_DIGEST_SIZE];
    uint8_t streaming[GM_SHA256_DIGEST_SIZE];
    
    /* One-shot */
    gm_result_void result = gm_sha256(test_data, strlen(test_data), one_shot);
    assert(GM_IS_OK(result));
    
    /* Streaming in chunks */
    gm_sha256_ctx_t ctx;
    result = gm_sha256_init(&ctx);
    assert(GM_IS_OK(result));
    
    result = gm_sha256_update(&ctx, "The quick ", 10);
    assert(GM_IS_OK(result));
    
    result = gm_sha256_update(&ctx, "brown fox ", 10);
    assert(GM_IS_OK(result));
    
    result = gm_sha256_update(&ctx, "jumps over ", 11);
    assert(GM_IS_OK(result));
    
    result = gm_sha256_update(&ctx, "the lazy dog", 12);
    assert(GM_IS_OK(result));
    
    result = gm_sha256_final(&ctx, streaming);
    assert(GM_IS_OK(result));
    
    /* Should match */
    assert(memcmp(one_shot, streaming, GM_SHA256_DIGEST_SIZE) == 0);
    
    printf("✓ test_sha256_streaming\n");
}

/* Test edge cases */
static void test_sha256_edge_cases(void) {
    uint8_t out[GM_SHA256_DIGEST_SIZE];
    gm_result_void result;
    
    /* NULL data with zero length should work */
    result = gm_sha256(NULL, 0, out);
    assert(GM_IS_OK(result));
    
    /* Large data */
    char large_data[8192];
    memset(large_data, 'A', sizeof(large_data));
    result = gm_sha256(large_data, sizeof(large_data), out);
    assert(GM_IS_OK(result));
    
    /* Test error cases */
    /* NULL output buffer */
    result = gm_sha256("test", 4, NULL);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    /* NULL context for init */
    result = gm_sha256_init(NULL);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    /* NULL context for update */
    result = gm_sha256_update(NULL, "test", 4);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    /* NULL context for final */
    result = gm_sha256_final(NULL, out);
    assert(GM_IS_ERR(result));
    gm_error_free(GM_UNWRAP_ERR(result));
    
    printf("✓ test_sha256_edge_cases\n");
}

int main(void) {
    printf("Running SHA256 tests...\n\n");
    
    test_sha256_vectors();
    test_sha256_streaming();
    test_sha256_edge_cases();
    
    printf("\n✅ All SHA256 tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_string.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/types/string.h"
#include "gitmind/error.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Test string creation */
static void test_string_new(void) {
    gm_result_string result = gm_string_new("hello world");
    assert(GM_IS_OK(result));
    
    gm_string_t str = GM_UNWRAP(result);
    assert(strcmp(str.data, "hello world") == 0);
    assert(str.length == 11);
    assert(str.capacity >= 12); /* room for null terminator */
    
    gm_string_free(&str);
    printf("✓ test_string_new\n");
}

/* Test empty string */
static void test_string_empty(void) {
    gm_result_string result = gm_string_new("");
    assert(GM_IS_OK(result));
    
    gm_string_t str = GM_UNWRAP(result);
    assert(gm_string_is_empty(&str));
    assert(str.length == 0);
    assert(str.data[0] == '\0');
    
    gm_string_free(&str);
    printf("✓ test_string_empty\n");
}

/* Test string append */
static void test_string_append(void) {
    gm_result_string result = gm_string_new("hello");
    assert(GM_IS_OK(result));
    
    gm_string_t str = GM_UNWRAP(result);
    
    /* Append string */
    gm_result_void append_result = gm_string_append(&str, " world");
    assert(GM_IS_OK(append_result));
    
    assert(strcmp(str.data, "hello world") == 0);
    assert(str.length == 11);
    
    /* Append more to test growth */
    append_result = gm_string_append(&str, "! This is a longer string to force reallocation");
    assert(GM_IS_OK(append_result));
    
    assert(gm_string_starts_with(&str, "hello world!"));
    
    gm_string_free(&str);
    printf("✓ test_string_append\n");
}

/* Test string views */
static void test_string_view(void) {
    /* View from C string */
    gm_string_view_t view = gm_string_view("hello world");
    assert(view.length == 11);
    assert(memcmp(view.data, "hello world", 11) == 0);
    
    /* View from owned string */
    gm_result_string result = gm_string_new("test string");
    assert(GM_IS_OK(result));
    
    gm_string_t str = GM_UNWRAP(result);
    gm_string_view_t str_view = gm_string_view_from_string(&str);
    
    assert(str_view.length == str.length);
    assert(str_view.data == str.data);
    
    /* Views can be compared */
    gm_string_view_t view2 = gm_string_view("test string");
    assert(gm_string_view_equals(str_view, view2));
    
    gm_string_free(&str);
    printf("✓ test_string_view\n");
}

/* Test string comparison */
static void test_string_compare(void) {
    gm_result_string r1 = gm_string_new("hello");
    gm_result_string r2 = gm_string_new("hello");
    gm_result_string r3 = gm_string_new("world");
    
    assert(GM_IS_OK(r1) && GM_IS_OK(r2) && GM_IS_OK(r3));
    
    gm_string_t s1 = GM_UNWRAP(r1);
    gm_string_t s2 = GM_UNWRAP(r2);
    gm_string_t s3 = GM_UNWRAP(r3);
    
    assert(gm_string_equals(&s1, &s2));
    assert(!gm_string_equals(&s1, &s3));
    
    /* Test prefix/suffix */
    assert(gm_string_starts_with(&s1, "hel"));
    assert(!gm_string_starts_with(&s1, "wor"));
    assert(gm_string_ends_with(&s1, "llo"));
    assert(!gm_string_ends_with(&s1, "wor"));
    
    gm_string_free(&s1);
    gm_string_free(&s2);
    gm_string_free(&s3);
    printf("✓ test_string_compare\n");
}

/* Test string concatenation */
static void test_string_concat(void) {
    gm_result_string r1 = gm_string_new("hello");
    gm_result_string r2 = gm_string_new(" world");
    
    assert(GM_IS_OK(r1) && GM_IS_OK(r2));
    
    gm_string_t s1 = GM_UNWRAP(r1);
    gm_string_t s2 = GM_UNWRAP(r2);
    
    gm_result_string result = gm_string_concat(&s1, &s2);
    assert(GM_IS_OK(result));
    
    gm_string_t concat = GM_UNWRAP(result);
    assert(strcmp(concat.data, "hello world") == 0);
    assert(concat.length == 11);
    
    gm_string_free(&s1);
    gm_string_free(&s2);
    gm_string_free(&concat);
    printf("✓ test_string_concat\n");
}

/* Test UTF-8 validation */
static void test_string_utf8(void) {
    gm_result_string result = gm_string_new("valid utf-8");
    assert(GM_IS_OK(result));
    
    gm_string_t str = GM_UNWRAP(result);
    gm_result_void valid = gm_string_validate_utf8(&str);
    assert(GM_IS_OK(valid));
    
    /* Test with invalid UTF-8 (continuation byte as start) */
    str.data[5] = '\x80';  /* Invalid UTF-8 start byte */
    valid = gm_string_validate_utf8(&str);
    assert(GM_IS_ERR(valid));
    gm_error_free(GM_UNWRAP_ERR(valid));
    
    gm_string_free(&str);
    printf("✓ test_string_utf8\n");
}

/* Test substring extraction */
static void test_string_substring(void) {
    gm_result_string result = gm_string_new("hello world");
    assert(GM_IS_OK(result));
    
    gm_string_t str = GM_UNWRAP(result);
    
    /* Extract "world" */
    gm_result_string sub_result = gm_string_substring(&str, 6, 5);
    assert(GM_IS_OK(sub_result));
    gm_string_t sub = GM_UNWRAP(sub_result);
    assert(strcmp(sub.data, "world") == 0);
    assert(sub.length == 5);
    gm_string_free(&sub);
    
    /* Extract from start */
    sub_result = gm_string_substring(&str, 0, 5);
    assert(GM_IS_OK(sub_result));
    sub = GM_UNWRAP(sub_result);
    assert(strcmp(sub.data, "hello") == 0);
    gm_string_free(&sub);
    
    /* Extract beyond end (should truncate) */
    sub_result = gm_string_substring(&str, 6, 100);
    assert(GM_IS_OK(sub_result));
    sub = GM_UNWRAP(sub_result);
    assert(strcmp(sub.data, "world") == 0);
    assert(sub.length == 5);
    gm_string_free(&sub);
    
    /* Start position out of bounds */
    sub_result = gm_string_substring(&str, 100, 5);
    assert(GM_IS_ERR(sub_result));
    gm_error_free(GM_UNWRAP_ERR(sub_result));
    
    /* NULL string */
    sub_result = gm_string_substring(NULL, 0, 5);
    assert(GM_IS_ERR(sub_result));
    gm_error_free(GM_UNWRAP_ERR(sub_result));
    
    gm_string_free(&str);
    printf("✓ test_string_substring\n");
}

/* Test string trimming */
static void test_string_trim(void) {
    /* Test various whitespace combinations */
    const char* test_cases[] = {
        "  hello world  ",
        "\t\thello world\t\t",
        "\n\nhello world\n\n",
        "\r\nhello world\r\n",
        "   \t\n\rhello world\r\n\t   ",
        "hello world",  /* No whitespace */
        "   ",          /* All whitespace */
        "",             /* Empty string */
        NULL
    };
    
    const char* expected[] = {
        "hello world",
        "hello world",
        "hello world",
        "hello world",
        "hello world",
        "hello world",
        "",
        ""
    };
    
    for (int i = 0; test_cases[i] != NULL; i++) {
        gm_result_string result = gm_string_new(test_cases[i]);
        assert(GM_IS_OK(result));
        
        gm_string_t str = GM_UNWRAP(result);
        
        gm_result_string trim_result = gm_string_trim(&str);
        assert(GM_IS_OK(trim_result));
        
        gm_string_t trimmed = GM_UNWRAP(trim_result);
        assert(strcmp(trimmed.data, expected[i]) == 0);
        
        gm_string_free(&str);
        gm_string_free(&trimmed);
    }
    
    /* Test NULL string */
    gm_result_string trim_result = gm_string_trim(NULL);
    assert(GM_IS_ERR(trim_result));
    gm_error_free(GM_UNWRAP_ERR(trim_result));
    
    printf("✓ test_string_trim\n");
}

int main(void) {
    printf("Running string type tests...\n\n");
    
    test_string_new();
    test_string_empty();
    test_string_append();
    test_string_view();
    test_string_compare();
    test_string_concat();
    test_string_utf8();
    test_string_substring();
    test_string_trim();
    
    printf("\n✅ All string tests passed!\n");
    return 0;
}

# /Users/james/git/git-mind/core/tests/unit/test_utf8.c
/* SPDX-License-Identifier: LicenseRef-MIND-UCAL-1.0 */
/* © 2025 J. Kirby Ross / Neuroglyph Collective */

#include "gitmind/utf8/validate.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Test valid ASCII */
static void test_utf8_ascii(void) {
    const char* valid[] = {
        "hello",
        "Hello, World!",
        "1234567890",
        "!@#$%^&*()_+-=",
        ""  /* Empty string is valid */
    };
    
    for (size_t i = 0; i < sizeof(valid) / sizeof(valid[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(valid[i], strlen(valid[i]));
        assert(err == GM_UTF8_OK);
    }
    
    printf("✓ test_utf8_ascii\n");
}

/* Test valid multibyte sequences */
static void test_utf8_multibyte(void) {
    /* Valid UTF-8 sequences */
    const struct {
        const char* data;
        size_t len;
        const char* desc;
    } valid[] = {
        /* 2-byte sequences */
        { "\xC2\x80", 2, "U+0080" },                    /* First 2-byte */
        { "\xDF\xBF", 2, "U+07FF" },                    /* Last 2-byte */
        
        /* 3-byte sequences */
        { "\xE0\xA0\x80", 3, "U+0800" },                /* First 3-byte */
        { "\xE0\xBF\xBF", 3, "U+0FFF" },                /* Valid 3-byte */
        { "\xED\x9F\xBF", 3, "U+D7FF" },                /* Before surrogates */
        { "\xEE\x80\x80", 3, "U+E000" },                /* After surrogates */
        { "\xEF\xBF\xBF", 3, "U+FFFF" },                /* Last 3-byte */
        
        /* 4-byte sequences */
        { "\xF0\x90\x80\x80", 4, "U+10000" },           /* First 4-byte */
        { "\xF4\x8F\xBF\xBF", 4, "U+10FFFF" },          /* Last valid Unicode */
        
        /* Mixed sequences */
        { "a\xC2\x80" "b", 4, "Mixed ASCII and 2-byte" },
        { "\xE2\x82\xAC\xE2\x82\xAC", 6, "€€" },        /* Two euro signs */
        { "Hello, \xE4\xB8\x96\xE7\x95\x8C!", 13, "Hello, 世界!" }
    };
    
    for (size_t i = 0; i < sizeof(valid) / sizeof(valid[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(valid[i].data, valid[i].len);
        if (err != GM_UTF8_OK) {
            printf("❌ Failed on valid sequence: %s (error %d)\n", 
                   valid[i].desc, err);
        }
        assert(err == GM_UTF8_OK);
    }
    
    printf("✓ test_utf8_multibyte\n");
}

/* Test overlong encodings */
static void test_utf8_overlong(void) {
    const struct {
        const char* data;
        size_t len;
        const char* desc;
    } overlong[] = {
        /* Overlong NULL */
        { "\xC0\x80", 2, "Overlong U+0000" },
        { "\xE0\x80\x80", 3, "Overlong U+0000" },
        { "\xF0\x80\x80\x80", 4, "Overlong U+0000" },
        
        /* Other overlong sequences */
        { "\xC0\xAF", 2, "Overlong slash" },
        { "\xE0\x80\xAF", 3, "Overlong slash" },
        { "\xF0\x80\x80\xAF", 4, "Overlong slash" },
        
        /* Overlong 2-byte */
        { "\xC1\xBF", 2, "Overlong U+007F" }
    };
    
    for (size_t i = 0; i < sizeof(overlong) / sizeof(overlong[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(overlong[i].data, overlong[i].len);
        if (err == GM_UTF8_OK) {
            printf("❌ Failed to reject overlong: %s\n", overlong[i].desc);
        }
        assert(err != GM_UTF8_OK);
    }
    
    printf("✓ test_utf8_overlong\n");
}

/* Test invalid start bytes */
static void test_utf8_invalid_start(void) {
    const struct {
        const char* data;
        size_t len;
        const char* desc;
    } invalid[] = {
        /* Invalid start bytes */
        { "\x80", 1, "Continuation byte as start" },
        { "\xBF", 1, "Continuation byte as start" },
        { "\xFE", 1, "Invalid 0xFE" },
        { "\xFF", 1, "Invalid 0xFF" },
        
        /* Invalid in sequences */
        { "\xF5\x80\x80\x80", 4, "F5 start byte" },
        { "\xF8\x80\x80\x80", 4, "F8 start byte" },
        { "\xFC\x80\x80\x80\x80", 5, "FC start byte" }
    };
    
    for (size_t i = 0; i < sizeof(invalid) / sizeof(invalid[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(invalid[i].data, invalid[i].len);
        if (err == GM_UTF8_OK) {
            printf("❌ Failed to reject invalid start: %s\n", invalid[i].desc);
        }
        assert(err == GM_UTF8_ERR_INVALID_START);
    }
    
    printf("✓ test_utf8_invalid_start\n");
}

/* Test truncated sequences */
static void test_utf8_truncated(void) {
    const struct {
        const char* data;
        size_t len;
        const char* desc;
    } truncated[] = {
        /* Missing continuation bytes */
        { "\xC2", 1, "2-byte missing 1" },
        { "\xE0", 1, "3-byte missing 2" },
        { "\xE0\xA0", 2, "3-byte missing 1" },
        { "\xF0", 1, "4-byte missing 3" },
        { "\xF0\x90", 2, "4-byte missing 2" },
        { "\xF0\x90\x80", 3, "4-byte missing 1" },
        
        /* Truncated in middle of string */
        { "Hello\xC2", 6, "Truncated after ASCII" },
        { "Test\xE0\xA0", 6, "Truncated 3-byte" }
    };
    
    for (size_t i = 0; i < sizeof(truncated) / sizeof(truncated[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(truncated[i].data, truncated[i].len);
        if (err != GM_UTF8_ERR_TRUNCATED) {
            printf("❌ Failed to detect truncated: %s (got %d)\n", 
                   truncated[i].desc, err);
        }
        assert(err == GM_UTF8_ERR_TRUNCATED);
    }
    
    printf("✓ test_utf8_truncated\n");
}

/* Test UTF-16 surrogates */
static void test_utf8_surrogates(void) {
    const struct {
        const char* data;
        size_t len;
        const char* desc;
    } surrogates[] = {
        /* UTF-16 surrogates (D800-DFFF) are invalid in UTF-8 */
        { "\xED\xA0\x80", 3, "U+D800 (first surrogate)" },
        { "\xED\xAF\xBF", 3, "U+DBFF (last high surrogate)" },
        { "\xED\xB0\x80", 3, "U+DC00 (first low surrogate)" },
        { "\xED\xBF\xBF", 3, "U+DFFF (last surrogate)" },
        { "\xED\xA5\x8C", 3, "U+D94C (random surrogate)" }
    };
    
    for (size_t i = 0; i < sizeof(surrogates) / sizeof(surrogates[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(surrogates[i].data, surrogates[i].len);
        /* The DFA rejects surrogates as invalid sequences (ERR_INVALID_START)
           This is correct - surrogates are detected at the byte level */
        if (err == GM_UTF8_OK) {
            printf("❌ Failed to reject surrogate: %s\n", surrogates[i].desc);
        }
        assert(err != GM_UTF8_OK);
    }
    
    printf("✓ test_utf8_surrogates\n");
}

/* Test out of range codepoints */
static void test_utf8_out_of_range(void) {
    const struct {
        const char* data;
        size_t len;
        const char* desc;
    } out_of_range[] = {
        /* Beyond U+10FFFF */
        { "\xF4\x90\x80\x80", 4, "U+110000" },
        { "\xF4\x90\x80\x81", 4, "U+110001" },
        { "\xF5\x80\x80\x80", 4, "U+140000" },
        { "\xF7\xBF\xBF\xBF", 4, "U+1FFFFF" }
    };
    
    for (size_t i = 0; i < sizeof(out_of_range) / sizeof(out_of_range[0]); i++) {
        gm_utf8_error_t err = gm_utf8_validate(out_of_range[i].data, 
                                               out_of_range[i].len);
        if (err != GM_UTF8_ERR_OUT_OF_RANGE && err != GM_UTF8_ERR_INVALID_START) {
            printf("❌ Failed to reject out of range: %s (got %d)\n", 
                   out_of_range[i].desc, err);
        }
        assert(err == GM_UTF8_ERR_OUT_OF_RANGE || err == GM_UTF8_ERR_INVALID_START);
    }
    
    printf("✓ test_utf8_out_of_range\n");
}

/* Test streaming validation */
static void test_utf8_streaming(void) {
    /* Test 1: Valid multi-chunk */
    {
        gm_utf8_state_t state;
        gm_utf8_state_init(&state);
        
        assert(gm_utf8_validate_chunk(&state, "Hello", 5) == GM_UTF8_OK);
        assert(gm_utf8_validate_chunk(&state, ", ", 2) == GM_UTF8_OK);
        assert(gm_utf8_validate_chunk(&state, "\xE4\xB8\x96\xE7\x95\x8C", 6) == GM_UTF8_OK);
        assert(gm_utf8_validate_chunk(&state, "!", 1) == GM_UTF8_OK);
        
        assert(gm_utf8_state_is_complete(&state));
    }
    
    /* Test 2: Split multibyte sequence */
    {
        gm_utf8_state_t state;
        gm_utf8_state_init(&state);
        
        /* Euro sign split across chunks */
        assert(gm_utf8_validate_chunk(&state, "\xE2", 1) == GM_UTF8_OK);
        assert(!gm_utf8_state_is_complete(&state)); /* Not complete */
        assert(gm_utf8_validate_chunk(&state, "\x82", 1) == GM_UTF8_OK);
        assert(!gm_utf8_state_is_complete(&state)); /* Still not complete */
        assert(gm_utf8_validate_chunk(&state, "\xAC", 1) == GM_UTF8_OK);
        assert(gm_utf8_state_is_complete(&state));  /* Now complete */
    }
    
    /* Test 3: Error in second chunk */
    {
        gm_utf8_state_t state;
        gm_utf8_state_init(&state);
        
        assert(gm_utf8_validate_chunk(&state, "abc", 3) == GM_UTF8_OK);
        assert(gm_utf8_validate_chunk(&state, "\xC0\x80", 2) != GM_UTF8_OK);
    }
    
    printf("✓ test_utf8_streaming\n");
}

/* Performance test (basic) */
static void test_utf8_performance(void) {
    /* Generate 1MB of ASCII data */
    size_t size = 1024 * 1024;
    char* buf = malloc(size);
    assert(buf != NULL);
    
    /* Fill with ASCII */
    for (size_t i = 0; i < size; i++) {
        buf[i] = 'A' + (i % 26);
    }
    
    /* Time the validation (rough estimate) */
    gm_utf8_error_t err = gm_utf8_validate(buf, size);
    assert(err == GM_UTF8_OK);
    
    free(buf);
    
    printf("✓ test_utf8_performance (validated 1MB)\n");
}

int main(void) {
    printf("Running UTF-8 validation tests...\n\n");
    
    test_utf8_ascii();
    test_utf8_multibyte();
    test_utf8_overlong();
    test_utf8_invalid_start();
    test_utf8_truncated();
    test_utf8_surrogates();
    test_utf8_out_of_range();
    test_utf8_streaming();
    test_utf8_performance();
    
    printf("\n✅ All UTF-8 tests passed!\n");
    return 0;
}

