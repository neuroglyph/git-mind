# ADR-0004: Content Attachments Belong in git-warp

- **Status:** Proposed
- **Date:** 2026-02-20
- **Deciders:** Git Mind maintainers
- **Related:** ADR-0002, ADR-0003, WARP Paper I (aion-paper-01), M13A VESSEL-CORE roadmap milestone
- **Upstream impact:** git-warp, git-cas

---

## 1. Context

The M13A (VESSEL-CORE) roadmap milestone calls for a content-on-node system: the ability to attach rich content (documents, specs, narratives) to graph nodes, stored as content-addressed blobs, with full CRDT versioning and time-travel.

The original plan placed this system entirely in git-mind: a `ContentStore` abstraction, a `_content` property convention, `git mind content set/show` commands, storage policy engine, and provenance receipts.

On review, the storage primitive — attaching a content-addressed blob to a graph node — is not a domain concern. It is a graph-level operation that belongs in git-warp.

### 1.1 The Paper Says So

WARP Paper I defines a WARP graph as `(S, α, β)` where:

- `S` is a finite directed multigraph (the skeleton)
- `α : V_S → WARP` assigns an **attachment** to every vertex
- `β : E_S → WARP` assigns an **attachment** to every edge

Attachments are full WARP graphs or **atoms**: `Atom(p)` for some payload `p ∈ P`, where P is "the stuff we are not going to model internally (bytestrings, floats, external object IDs, ...)".

Currently, git-warp models nodes and edges with flat key-value properties. There is no first-class concept of an attachment payload. Content-addressed blob attachment is the concrete realization of `Atom(p)` — it gives nodes (and potentially edges) the ability to carry opaque payload data, exactly as the paper's formalism requires.

### 1.2 The Layering Argument

If content attachment lives in git-warp:

- **Time-travel works for free.** Content SHAs are properties; `materialize({ ceiling })` already handles property-level time-travel.
- **Multi-writer merge works for free.** CRDT conflict resolution on the SHA property follows existing semantics.
- **Observer scoping works for free.** Content visibility follows node visibility.
- **Provenance is already tracked.** Every property mutation carries tick/writer metadata.
- **Any tool on git-warp gets it.** Not just git-mind — any future consumer of the WARP graph API can attach and retrieve content.

If content attachment lives in git-mind, all of the above must be re-implemented or worked around at the application layer, duplicating guarantees that already exist in the substrate.

---

## 2. Decision

**Content attachment is a git-warp responsibility, not a git-mind responsibility.**

git-warp should:

1. **Install `git-cas` as a dependency** — providing content-addressed blob storage backed by the git object store.
2. **Expose an API for attaching content to nodes** — this could be as simple as a property convention (e.g., a CAS key stored as a node property), or a dedicated method on the patch/node API. The exact API design is git-warp's decision.
3. **Expose content read/retrieval** — given a node, retrieve its attached content blob.

git-mind's role becomes a thin CLI/UX layer:

- `git mind content set <node> <file>` — CLI command that calls the git-warp attachment API
- `git mind content show <node>` — CLI command that reads and displays attached content
- `git mind content edit <node>` — editor integration, crash recovery, conflict handling (M13B)
- Storage policy (MIME thresholds, size limits) — domain-level configuration
- Materialization templates that consume attached content (M14)

---

## 3. Alternatives Considered

### 3A: Content system entirely in git-mind (original M13A plan)

git-mind implements `ContentStore` over git plumbing, manages `_content` property convention, handles CAS operations directly.

**Rejected because:**
- Duplicates CRDT/time-travel/observer guarantees already in git-warp
- Other git-warp consumers cannot benefit
- Thickens the git-mind layer with storage plumbing that isn't domain logic
- Diverges from the paper's formalism, which places attachments at the graph level

### 3B: Content as plain git-warp properties (no CAS, inline values)

Store content directly as property values on nodes.

**Rejected because:**
- Property values are not designed for large payloads (documents, images)
- No deduplication across nodes with identical content
- No streaming/chunking for large files
- Misses the `Atom(p)` semantics — atoms are opaque external references, not inline data

---

## 4. Consequences

### For git-warp

- New dependency: `git-cas`
- New API surface: content attachment on nodes (and potentially edges)
- Closer alignment with Paper I's `(S, α, β)` formalism
- git-warp's README/docs should reference the attachment concept

### For git-mind

- M13A scope shrinks significantly — git-mind provides CLI/UX, not storage
- M13B (content editing UX) is unaffected — editor integration remains a git-mind concern
- Existing property-based workflows are unaffected
- The `_content` property convention (if that's the API shape) is documented as a git-warp concern, not a git-mind convention

### For the roadmap

- M13A splits: upstream work in git-warp (attachment API), then thin git-mind CLI layer
- M14 (FORGE/materialization) benefits — the materialization pipeline reads content via the same git-warp API, no git-mind-specific content abstraction needed
- M16 (CITADEL/trust) benefits — trust-scoped content visibility is just trust-scoped property visibility

---

## 5. Relationship to the Paper

| Paper concept | git-warp realization |
|---|---|
| `Atom(p)` — opaque payload | CAS blob referenced by SHA |
| `α(v)` — vertex attachment | Content property on node |
| `β(e)` — edge attachment | Content property on edge (future) |
| `P` — set of atomic payloads | Git object store (content-addressed) |
| Depth-0 attachment | A node whose attachment is a single blob |
| Deeper attachments | Future: nested WARP graphs as attachments (not in scope for this decision) |

This ADR addresses the depth-0 case: nodes carry `Atom(p)` payloads via CAS. The full recursive attachment model (`α(v)` mapping to arbitrary WARP graphs) is a future concern — but this decision establishes the correct layering so that deeper attachments can be added later without architectural rework.

---

## 6. Open Questions (for git-warp)

These are implementation details for the git-warp maintainers:

1. **API shape:** Dedicated `node.attach(blob)` / `node.content()` methods, or a property convention like `_content: <cas-sha>`? Either works; the former is more discoverable.
2. **Edge attachments:** Should edges also support content attachment from day one, or is node-only sufficient for the first iteration?
3. **Integrity verification:** Should `getContent()` verify the SHA on read, or trust the object store?
4. **MIME / metadata:** Should git-warp store content metadata (MIME type, size, encoding) alongside the CAS reference, or leave that to consumers like git-mind?
