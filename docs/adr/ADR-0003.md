# ADR-0003: Extension Manifest Design and Terminology Decisions

- **Status:** Accepted
- **Date:** 2026-02-17
- **Deciders:** Git Mind maintainers
- **Amends:** ADR-0001, ADR-0002
- **Related:** M10.5 ContextEnvelope, M11 Blueprint, docs/contracts/extension-manifest.schema.json

---

## 1. Context

Git Mind's architecture separates the CRDT engine (git-warp) from semantic concerns (prefixes, edge types, views, lenses, rules). M11 Blueprint formalizes how these semantic concerns are packaged and declared via **Extensions**.

This ADR captures four design decisions made during M10.5–M11 planning:

1. **Extension manifest format and capability model**
2. **Terminology collision: two meanings of "materialize"**
3. **Observer registry: where observer configs live**
4. **Context envelope field naming: `extensionLock` vs `extensionSet`/`lockHash`**

---

## 2. Decision 1: YAML Manifest Format

**Decision:** Extension manifests are declared as JSON Schema documents (`extension-manifest.schema.json`) validated at load time. The runtime representation is a plain JS object conforming to the schema.

**Rationale:**

- JSON Schema (Draft 2020-12) is already used for all git-mind contract files, providing a consistent validation layer via AJV.
- YAML source files may be used for human authoring (extensions can declare their manifest in `extension.yaml`), but the canonical contract is the JSON Schema.
- Avoids a separate manifest DSL; leverages existing tooling.

**Capability model:** Extensions declare capabilities declaratively:
- `domain`: prefixes, edge types, status values — the vocabulary this extension owns
- `views`: declarative view configs contributed to the view registry
- `lenses`: lens names contributed (implementations registered separately in JS)
- `rules`: integrity rule declarations for the doctor subsystem
- `syncAdapters`: external sync source adapters (e.g., GitHub Issues, Linear)
- `materializers`: artifact render targets with supported format list

**Why registry-driven semantics:** Views, lenses, and rules are registered at boot time by the extension loader. The manifest is the contract; the implementation is the runtime side effect. This mirrors the existing `defineView()`/`defineLens()` pattern — extensions simply call these from their entry point, with the manifest providing a machine-readable declaration of what they contribute.

---

## 3. Decision 2: Terminology Collision — "Materialize"

**Warning:** Two completely unrelated operations share the word "materialize":

| Term | Where | What it means |
|------|-------|---------------|
| `graph.materialize({ ceiling: tick })` | git-warp API | Time-travel: mutate graph instance to a Lamport tick ceiling. **Destructive — no undo.** |
| `materialize` command (planned) | git-mind CLI | Artifact rendering: render a graph projection to Markdown/HTML/PDF files. |

**Decision:** Internally, the artifact pipeline uses the terms **"render"** and **"emit"** for the CLI command and pipeline functions. The user-facing CLI command may be called `materialize` for discoverability, but internal code and documentation prefer `renderArtifact`, `emitProjection`, etc.

ADR-0001 and ADR-0002 use "materialization" in the artifact-rendering sense. This ADR formally acknowledges the collision and establishes the internal convention.

**Impact on schemas:**
- `materialization-spec.schema.json` and `projection-result.schema.json` retain "materialization" in their names for user-facing clarity.
- Internal function names should avoid `materialize` to prevent confusion with the git-warp API.

---

## 4. Decision 3: Observer Registry Lives in the Graph

**Decision:** Observer profiles are stored as `observer:<name>` nodes in the WARP graph, with properties `match`, `expose`, `redact`. No separate registry file or external config.

**Rationale:**

- "Graph as source of truth" — observer profiles are versioned, CRDT-native, and visible via `git mind nodes --prefix observer`.
- No chicken-and-egg: the unfiltered base graph is always loaded first; the observer config is read from it before creating the filtered view.
- Follows the same pattern as epoch markers (`epoch:<sha12>` nodes) — semantic data stored in the graph.

**Resolution flow:**
```
loadGraph(cwd) → full (unfiltered) WarpGraph
if asOf: graph.materialize({ ceiling: tick })   // git-warp time-travel
if observer != null:
  propsMap = graph.getNodeProps('observer:' + name)
  config = { match, expose?, redact? }
  view = graph.observer(name, config)
  → use 'view' for all subsequent reads
else:
  → use 'graph' for all subsequent reads
```

**Error handling:** If `observer:X` does not exist, emit a clear error:
> `Observer 'X' not found. Define it with: git mind set observer:X match 'prefix:*'`

---

## 5. Decision 4: Context Envelope Field Naming

**Decision:** The `src/context-envelope.js` typedef uses `extensionLock` for the field pinning the active extension set. BLP-002 (context-envelope.schema.json) expands this to two fields: `extensionSet` (the set identifier) and `lockHash` (the lock hash), to separate concerns.

**Current state:** `extensionLock` in the JS typedef is a single opaque SHA combining both. The schema splits it into `extensionSet` + `lockHash` for forward compatibility with the extension registry.

**Path forward:** A future issue will rename `extensionLock` → `extensionSet` in the JS typedef and add `lockHash` as a separate field, with a deprecation shim for backward compatibility.

---

## 6. Amendments to Prior ADRs

### ADR-0001 Amendment
Section "Materialized artifacts are derived outputs" is amended to note:
- The term "materialization" in ADR-0001 refers exclusively to artifact rendering (git-mind's planned `render`/`materialize` command), NOT to git-warp's `materialize({ ceiling })` time-travel API.

### ADR-0002 Amendment
Section 5 ("Materialization and writeback are transactional, deterministic, and receipt-backed") is amended to note:
- The `ProvenanceEnvelope` schema (`docs/contracts/provenance-envelope.schema.json`) formalizes the "receipt-backed" requirement.
- The `ArtifactBundle` schema (`docs/contracts/artifact-bundle.schema.json`) formalizes the `ephemeral`/`attested` artifact class distinction.

---

## 7. Consequences

- Extension system is registry-driven, manifest-declared. No framework required.
- Two uses of "materialize" coexist; internal code uses "render"/"emit" to disambiguate.
- Observer profiles are first-class graph nodes — discoverable, versioned, CRDT-native.
- `extensionLock` field will be split in a future issue; existing code is forward-compatible.
