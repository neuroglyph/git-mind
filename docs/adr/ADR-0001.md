# ADR-0001: Worktree Independence and Materialization Architecture

- **Status:** Accepted
- **Date:** 2026-02-15
- **Deciders:** Git Mind maintainers
- **Related:** WARP graph model, git-warp, @git-stunts/git-cas, extension runtime, trust roadmap

## Context

Git Mind is powered by git-warp and WARP graphs, with storage/materialization acceleration via `@git-stunts/git-cas`.  
A key architectural subtlety is now explicit:

- The Git **worktree** does **not** control Git Mind graph state.
- Git Mind retains full causal history and can project/materialize against arbitrary causal points independently of checkout state.
- Materialized artifacts (Markdown/HTML/PDF/etc.) are derived outputs from graph projections, not canonical source entities.

This ADR captures decisions made during discussion of:

1. Worktree vs graph authority boundaries  
2. Generic materialization model  
3. Why materializations are not regular tracked files by default  
4. Artifact indexing safeguards (`.gitignore` and beyond)  
5. Practical Git analogy and where Git Mind diverges

---

## Decision 1: Two-State-Space Model is Canonical

### We formally distinguish:

1. **Git worktree state**
- Filesystem snapshot for standard Git workflows.
- Convenient default context for queries (e.g., HEAD).

2. **Git Mind/WARP graph state**
- Full cryptographically causal knowledge graph across time/forks/writers.
- Not bounded by current checkout.
- Authoritative substrate for semantic truth.

### Consequence

`HEAD` is a **query parameter** (default context), not the source of truth.

---

## Decision 2: Graph Truth > File Truth

Git Mind adopts:

- **Canonical truth:** Graph entities + causal receipts + content objects
- **Derived truth:** Materialized artifacts (md/html/pdf/json/etc.)

Materialized files are **compiled outputs**, not canonical authored state.

---

## Decision 3: Materialization is a Generic Runtime Primitive

We define materialization as a generic pipeline independent of any single domain node type.

## Pipeline

1. **Source layer**  
WARP graph state and receipts via git-warp (backed/cached by git-cas).

2. **Projection layer**  
View/lens + context envelope (as-of, observer, trust, active extensions).

3. **Materialization layer**  
Renderer/template transforms projection into artifact bundle.

4. **Artifact store layer**  
Output can be ephemeral filesystem export and/or persisted in CAS.

### Important modeling rule

Materialized files are not represented as ordinary domain nodes by default.  
They are derived artifacts linked to provenance.

---

## Decision 4: Context Envelope is Mandatory for Semantically Variant Operations

Operations whose output can vary must be context-explicit (or use deterministic defaults):

- `asOf` / `at` (ref/receipt/tick)
- `observer`
- `trustPolicy`
- `extensionSet` (+ lock/hash)
- renderer/template version (for materialization)

### Rule: No Hidden HEAD Coupling

Any varying output must not silently depend on ambient worktree state beyond explicit defaults.

---

## Decision 5: Storage Strategy for Node-Scoped Content

For content like ADR bodies:

- Preferred canonical backend: **git-cas-backed content objects**
- Node stores semantic metadata + content references
- Materializers render node content to md/html/pdf on demand

Git notes may be supported as compatibility/interoperability path, but are not the strategic canonical store.

---

## Decision 6: Deterministic Materialization Caching

Materializations should be cacheable by deterministic key derived from:

- projection input/frontier hash
- view/lens definition hash
- observer/trust hash
- renderer/template/version hash
- extension lock hash
- render options hash

If cache hit exists in CAS, reuse; otherwise compute, store, return.

---

## Decision 7: Artifact Classes

1. **Ephemeral artifacts**
- Local/CI previews
- Not intended as repository source

2. **Attested artifacts**
- Evidence/compliance/publication outputs
- Persisted with provenance envelope/receipt
- Optionally signed under trust policy

---

## Decision 8: Repository Hygiene and Indexing Controls

`.gitignore` alone is insufficient.

### Defense-in-depth policy

1. **Default output outside repo root** (preferred)
- e.g., XDG/`~/.cache/git-mind/materializations`

2. If repo-local output is needed:
- restrict to dedicated subtree (e.g., `.gitmind/materialized/`)
- ignore subtree in `.gitignore`

3. Add local fallback guard:
- `.git/info/exclude`

4. Enforce at commit time:
- pre-commit hook blocks generated artifact paths/signatures

5. Enforce in CI:
- fail if forbidden generated artifacts are tracked

6. Use publish allowlist:
- only explicitly approved generated paths may be committed

### Principle

Generated artifacts are tracked only via explicit publish workflow, never by accident.

---

## Decision 9: Why Not “Just Regular Files in Git”

Defaulting to tracked regular files for materializations is rejected because:

- introduces dual canonical truth (graph + files)
- collapses multi-context outputs into false singular truth
- causes high churn/noise in history
- increases merge conflict burden on derived data
- weakens reproducibility unless full render context is pinned
- risks trust-context leakage in global workflows
- bloats repo with generated/binary artifacts

---

## Decision 10: Relationship to Git’s Existing Problem

Git already has analogous source-vs-build-artifact friction in worktrees.

Git Mind is the same class of problem **plus extra semantic dimensions**:
- as-of context
- observer context
- trust policy
- renderer/template version

Therefore stricter artifact discipline is not optional—it is architecturally required.

---

## CLI Semantics (Directional)

```bash
# Context-explicit graph query
git mind view roadmap --at HEAD
git mind view roadmap --at refs/heads/release/1.2

# Context-explicit materialization
git mind materialize adr:0007 --at main~30 --format pdf
git mind materialize view:roadmap:critical-path \
--at refs/tags/q1-freeze \
--observer auditor \
--trust approved-only

# Content-on-node
git mind content set adr:0007 --from ./adr.md
git mind content show adr:0007 --at main~12
```

---

Invariants Adopted
1.	Determinism over convenience
2.	Graph truth over file truth
3.	Worktree-aware but never worktree-bound
4.	No hidden context coupling for variant outputs
5.	Materialization is a pure derivation from explicit inputs
6.	Derived artifacts are non-canonical by default
7.	Generated artifact tracking requires explicit publish policy
8.	Provenance envelope required for attested outputs

---

Consequences

Positive
- clean separation of semantics and presentation
- reproducible historical/observer/trust-specific rendering
- reduced repo pollution and merge noise
- stronger audit/compliance posture
- aligns with future trust features in git-warp

Costs
- higher implementation complexity in materialization runtime
- requires robust contracts and CLI context ergonomics
- requires hooks/CI policy infrastructure
- stronger upfront design discipline

---

Follow-up Work Items
1.	Define MaterializationSpec v1 contract
2.	Define ProjectionResult v1 and ArtifactBundle v1 schemas
3.	Implement deterministic materialization ID/key algorithm
4.	Add default external cache output target
5.	Add repo-local output allowlist policy
6.	Add pre-commit and CI generated-artifact guards
7.	Define node content object schema (CAS-backed)
8.	Add provenance envelope for materialized outputs
9.	Add --at/--observer/--trust context across relevant commands
10.	Document explicit publish workflow for tracked generated outputs
