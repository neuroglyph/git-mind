# ADR-0002: Graph-Native Content, Deterministic Materialization, and Workspace Bridge

- **Status:** Accepted
- **Date:** 2026-02-15
- **Deciders:** Git Mind maintainers
- **Supersedes:** None
- **Amends:** ADR-0001 (Worktree Independence and Materialization Architecture)
- **Related:** M10–M18 roadmap, Architecture Laws, Review Rubric

---

## 1. Context

ADR-00XX established the foundational separation:

- worktree state is a context, not authority,
- graph state is canonical,
- materialized artifacts are derived.

Since that decision, we refined critical execution details:

1. The primary adoption risk is **editing friction** for content-on-node workflows.
2. Editor/plugin-first strategy is insufficient as a universal adoption path.
3. A lower compatibility layer is required to preserve normal file/editor UX.
4. Materialization and editing must remain deterministic and provenance-linked.
5. Cross-context semantics (`asOf`, observer, trust) must be explicit everywhere.

This ADR captures those follow-on decisions and operationalizes the architecture.

---

## 2. Decision Summary

We adopt five concrete decisions:

1. **Content-on-node remains canonical**, but editing must be file-native in UX.
2. **Sync Workspace Mode** (projected workspace daemon) is the default compatibility bridge.
3. **FUSE mount is optional performance mode**, not required for baseline operation.
4. **Graph→workspace invalidation/signaling is mandatory** for correctness in live editors.
5. **Materialization and writeback are transactional, deterministic, and receipt-backed**.

---

## 3. Decision Details

---

## D1 — Canonical Model: Graph Truth, Content Objects, Derived Artifacts

### Decision
- Node-associated content is stored as canonical content objects (CAS-backed), referenced from graph entities.
- Materialized files remain derived artifacts, non-canonical by default.

### Why
- Prevents dual truth drift (graph vs generated files).
- Preserves causal lineage and time-travel semantics.
- Aligns with trust-scoped and observer-scoped projections.

### Consequences
- Requires explicit edit/writeback workflow.
- Enables provenance-first audits and deterministic replay.

---

## D2 — Editing UX: File-Native Interaction Over Graph-Native Storage

### Decision
`git mind edit <entity>` and workspace editing must feel equivalent to normal file editing:
- open in `$EDITOR` / VS Code
- edit/save naturally
- writeback handles diff/validate/commit/receipt.

### Why
- Adoption risk is primarily UX friction, not conceptual mismatch.
- If editing feels clunky, users bypass graph truth and create shadow workflows.

### Consequences
- Editing UX is a flagship capability, not a convenience command.
- Conflict UX, recovery, and low latency become product-critical.

---

## D3 — Bridge Strategy: Sync Workspace Mode First, FUSE Second

### Decision
Introduce adapter abstraction for workspace projection:

- `VFSAdapter` interface (contract)
- `SyncAdapter` (projected workspace daemon) as universal default MVP
- `FuseAdapter` as optional advanced/performance mode

### Why
- Sync mode avoids native build/kernel permission barriers.
- Works across enterprise and constrained environments.
- Delivers immediate adoption with existing editors/tools.

### Consequences
- Disk footprint and watch complexity accepted as MVP tradeoff.
- FUSE pursued later for lazy loading/perf improvements.

---

## D4 — Workspace Path Policy: Editable vs Derived

### Decision
Projected workspace enforces path semantics:

- **Editable:** `/entities/**` (and explicitly designated draft paths)
- **Read-only derived:** `/views/**`, `/materialized/**`

### Why
- Prevents accidental edits to non-canonical derived outputs.
- Preserves single canonical write path for semantic mutations.

### Consequences
- Write attempts to derived paths fail with actionable error guidance.
- Publish workflow remains explicit and policy-controlled.

---

## D5 — Graph→Editor Signaling Is Required Infrastructure

### Decision
Graph updates must invalidate affected projected paths and emit file-change-visible updates for editors.

### Why
- Without signaling, editors display stale content after graph changes (e.g., pull/sync).
- Stale editor state erodes trust and creates phantom overwrite risk.

### Consequences
- Event bus + invalidation mapping becomes a core subsystem.
- Requires debounce/coalescing and self-write loop suppression.

---

## D6 — Writeback Semantics: Transactional and Conflict-Aware

### Decision
Writeback pipeline uses base snapshot semantics:
- capture base content hash + base frontier on open
- on save: diff → validate → attempt commit
- if frontier moved incompatibly: explicit conflict path (no silent overwrite)
- always emit receipt metadata.

### Why
- Concurrency is unavoidable in multi-writer/time-travel system.
- Silent stomps are unacceptable for provenance integrity.

### Consequences
- Conflict workflow and recovery UX must be first-class.
- Status/diagnostics must expose pending/failed writebacks clearly.

---

## D7 — Context Envelope Is Mandatory for Variant Outputs

### Decision
All variant operations must accept (explicit or deterministic default):
- `asOf`
- `observer`
- `trustPolicy`
- `extensionLock`/version context

Resolved context must be visible in metadata.

### Why
- Prevents hidden HEAD/worktree coupling.
- Preserves reproducibility and interpretation clarity across contexts.

### Consequences
- CLI surface standardization (`--at`, `--observer`, `--trust`) is required.
- Context handling is a platform concern, not command-local logic.

---

## D8 — Deterministic Materialization & Cache Keying

### Decision
Materialization cache identity includes:
- projection frontier/input hash
- context envelope hash
- renderer/template/version hash
- extension lock hash
- options hash

### Why
- Guarantees reproducible artifacts.
- Prevents stale/misattributed cache reuse.

### Consequences
- Renderer/version pinning required.
- Determinism tests become release gates.

---

## D9 — Artifact Hygiene Enforcement: Defense-in-Depth

### Decision
Prevent accidental tracking of generated artifacts with layered controls:
1. default output outside repo root
2. strict in-repo generated directories if used
3. `.gitignore` + local exclude
4. pre-commit checks
5. CI enforcement
6. publish allowlist for intentional tracked artifacts only

### Why
- `.gitignore` alone is bypassable and insufficient.
- Protects normal Git workflows from generated noise/pollution.

### Consequences
- Mechanical policy scripts and CI gates are part of core ops.
- Publication of generated artifacts is explicit, never incidental.

---

## 4. Architecture Invariants Reinforced

1. Graph truth is canonical.
2. Worktree is a default context, not authority.
3. No hidden context coupling.
4. Materialization is pure derivation from explicit inputs.
5. Derived artifacts are non-canonical unless explicitly published.
6. Writeback is transactional and receipt-backed.
7. Workspace bridge must preserve native editor ergonomics.
8. Determinism and provenance outrank convenience.

---

## 5. Alternatives Considered

### A) Plugin-first strategy (VS Code/JetBrains as primary path)
- **Rejected as primary**: fragmented ecosystem and high maintenance cost.
- **Kept as optional UX layer** over shared core APIs.

### B) Custom web editor as primary interface
- **Deferred**: high product surface area; risks delaying core architecture.
- Useful later for multi-user/browser-native workflows.

### C) “Just commit materialized files”
- **Rejected**: dual truth, high churn, merge noise, context collapse, trust leakage risk.

### D) FUSE-only approach
- **Rejected for MVP**: installation/permission friction too high for broad adoption.

---

## 6. Risks and Mitigations

| Risk | Severity | Mitigation |
|---|---:|---|
| Editing UX rejection | High | One-command edit flow + Sync Workspace Mode |
| Stale editor state | High | Event bus + invalidation + file-change signaling |
| Writeback conflicts/confusion | High | explicit conflict artifacts + guided merge flow |
| Artifact pollution | Medium | ignore + hooks + CI + allowlist |
| Hidden context coupling | High | mandatory context envelope + metadata echo |
| Non-deterministic renders | High | deterministic keying + cross-env tests |

---

## 7. Implementation Impact (Roadmap Binding)

This ADR binds to:

- **M10.5 CONTEXT** (context envelope integration)
- **M13A/B VESSEL** (content core + edit UX)
- **M14 FORGE** (deterministic materialization)
- **M14.5 SIGNAL** (graph subscription/invalidation)
- **M15 BRIDGE** (Sync Workspace default)
- **M15.5 FUSE** (optional perf mode)

---

## 8. Acceptance Criteria for This ADR

This ADR is considered implemented when:

1. `git mind edit` provides seamless temp-file/editor/writeback flow with conflict handling.
2. Sync Workspace Mode supports editable entity paths and read-only derived paths.
3. Graph updates propagate to projected workspace/editor-visible change events.
4. Materialization and writeback emit provenance receipts/envelopes.
5. Context envelope is surfaced and respected across variant operations.
6. Artifact hygiene gates are active in pre-commit and CI.

---

## 9. Operational Guidance

- Prefer Sync Workspace Mode as default docs/examples path.
- Treat FUSE as advanced mode; never required for standard onboarding.
- Keep generated artifacts out of tracked source unless explicit publish policy permits.
- Enforce architecture laws via review rubric and automated gates.

---

## 10. Notes

This ADR does not change ADR-00XX’s core separation model; it operationalizes it for real-world adoption and editor-native workflows.